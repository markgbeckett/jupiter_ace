DECIMAL ( ALL NUMBERS ARE DECIMAL UNLESS OTHERWISE STATED )

( DEFINER FOR SMALL MACHINE-CODE ROUTINES )
( SEE MANUAL. P. 147 )
DEFINER CODE
  DOES>
    CALL
;

( CASE CONSTRUCT FOR JUPITER ACE / MINSTREL 4TH )

( CHECK SYNTAX GUIDES MATCH )
: ?PAIRS ( M N -- FLAG )
  = 0= ( ARE THEY NOT EQUAL? )
  IF
    ." ERROR 5" CR ABORT ( ABORT COMPILATION, IF NOT EQUAL )
  THEN
;

0 COMPILER CASE
  0 ( MARKER ON STACK, USED BY ENDCASE TO CHECK DONE )
  9 ( SYNTAX GUIDE, MUST MATCH WITH 'OF' )
RUNS>
  DROP ( NOTHING TO DO EXCEPT DROP ADDR OF PARAMETER FIELD )
;

2 COMPILER OF
  9 ?PAIRS ( CHECK PRECEDED BY CASE OR ENDOF )
  HERE ( SAVE CURRENT DICTIONARY LOCATION FOR ENDOF )
  0 , ( RESERVE TWO BYTES AT THAT LOCATION )
  7 ( SYNTAX GUIDE, MUST MATCH WITH 'ENDOF' )
RUNS>
  >R ( SAVE PARAMETER-FIELD ADDR )
  OVER = ( CHECK FOR MATCH WITH CASE VALUE, PRESERVING COPY OF INPUT )
  R> ( RECOVER PARAMETER-FIELD ADDR )
  SWAP ( BRING MATCH RESULT BACK TO TOP OF STACK )
  IF ( INDICATES MATCH ) 
    DROP DROP ( DROP PARAMETER-FIELD ADDR AND INPUT, AS DONE )
  ELSE
    @ ( RETRIEVE OFFSET TO NEXT 'OF' FROM PARAMETER FIELD )
    R> + >R ( ADVANCE TO NEXT 'OF' STATEMENT )
  THEN
;

( IF SYNTAX IS CORRECT, TOS = 7 AND 2OS = PARAM FIELD OF 'OF' )
2 COMPILER ENDOF
  7 ?PAIRS ( CHECK PRECEDED BY 'OF' )
  HERE ( PUT CURRENT DICTIONARY LOCATION ON STACK )
  SWAP ( SWAP WITH ADDRESS OF PARAM FIELD FOR 'OF' )
  0 , ( RESERVE TWO BYTES IN DICTIONARY )
  OVER OVER - ( WORK OUT OFFSET FROM 'OF' TO 'HERE' )
  SWAP ! ( STORE IN PARAMETER FIELD OF 'OF' )
  9 ( SYNTAX GUIDE, MUST MATCH TO 'OF' OR 'OTHERWISE' )
RUNS>
  @ ( RETRIEVE OFFSET TO JUST AFTER 'ENDCASE' FROM PARAMETER FIELD )
  R> + 4 - >R ( APPLY TO RETURN ADDRESS, NEED TO BACKTRACK BY 4 )
;

0 COMPILER OTHERWISE
  9 ?PAIRS ( CHECK PRECEDED BY 'CASE' OR 'ENDOF' )
  8 ( SYNTAX GUIDE, MUST MATCH WITH 'ENDCASE' )
RUNS>
  DROP DROP ( DROP PARAMETER-FIELD ADDR AND INPUT, AS DONE )
;

0 COMPILER ENDCASE
  8 ?PAIRS ( CHECK PRECEDED BY 'OTHERWISE' )
  BEGIN 
    ?DUP ( IF PARAMETER-FIELD ADDRESS NON-ZERO, DUPLICATE )
  WHILE ( OTHERWISE, ALL DONE )
    HERE OVER - ( WORK OUT OFFSET )
    SWAP ! ( STORE IN PARAMETER FIELD OF 'ENDOF' )
  REPEAT ( DO FOR EACH 'ENDOF' )
RUNS>
  DROP ( DROP PARAMETER FIELD, AS DONE )
;

( SPACE IN WHICH TO HOLD COPY OF DISPLAY BUFFER )
( FOR DOUBLE BUFFERING )
( PROVIDED THIS IS START OF DICTIONARY, AFTER CODE, SHOULD )
( RESIDE AT #3C76 )
CREATE BUFFER 704 ALLOT

( CLEAR BUFFER - SETTING EACH CELL TO SPACE )
: FRAMECLEAR
    [ 3DVIEW 12 + ] LITERAL CALL
;

( COPY BUFFER INTO DISPLAY )
: FRAMEUPDATE
    [ 3DVIEW 15 + ] LITERAL CALL
;

( COPY DISPLAY INTO BUFFER )
: FRAMEGRAB
    [ 3DVIEW 18 + ] LITERAL CALL
;

( PRINT STRING TO BUFFER )
: FTYPE
    [ 3DVIEW 21 + ] LITERAL CALL
;

( REPRODUCED FROM S. VICKERS 'FORTH PROGRAMMING', P 143 )
: .S ( -- )
    ( USEFUL FOR DEBUGGING )
    15419 @ HERE 12 +
    OVER OVER -
    IF
	DO
	    I @
	    .
	2 +LOOP
    ELSE
	DROP
	DROP
    THEN
;

( HALT WORD FROM S. VICKERS, "PROGRAMMING FORTH", P. 147 )
CODE HALT
    118 C, 253 C, 233 C,

( PAUSE FOR N/50 SECONDS ) 
: PAUSE ( NN -- )
    0 DO
	HALT
    LOOP
;

( RANDOM NUMBER GENERATOR FROM S. VICKERS, "PROGRAMMING FORTH", P. 83 )
0 VARIABLE SEED

( UPDATE RANDOM-NUMBER SEED )
: SEEDON
    SEED @ 75 U* 75 0 D+
    OVER OVER U< - -
    1- DUP SEED !
;

( GENERATE RANDOM NUMBER )
: RND ( N -- RND(N) )
    SEEDON U* SWAP DROP
;

( SET RANDOM NUMBER SEED )
( THIS IS SLIGHTLY DIFFERENT FROM VERSION IN MANUAL, WHICH I )
( THINK CONTAINS A BUG )
: RAND ( N -- )
    ?DUP 0=
    IF
	15403 @ 
    THEN
    
    SEED !
;

( THE FOLLOWING TWO ROUTINES ARE USED TO )
( HELP IDENTIFY A REGION OF CODE FOR PROFILER )
( IN EIGHTY-ONE EMULATOR )
CODE MON
    253 C, 233 C,  ( JP <IY> )

CODE MOFF
    253 C, 233 C, ( JP <IY> )

: 2DUP ( X Y -- X Y X Y )
    OVER
    OVER
;

: 3DUP ( X Y Z -- X Y Z X Y Z )
    3 PICK
    3 PICK
    3 PICK
;

0 VARIABLE LASTKEY  ( LAST KEY TO BE PRESSED )
0 VARIABLE USEJOYSTICK ( INDICATES WHETHER JOYSTICK SUPPORT )
0 VARIABLE GETKEYCNT ( TIMING MULTIPLIER FOR KEYBOARD/ JOYSTICK MODE )

( CHECK IF JOYSTICK INTERFACE CONNECTED )
: CHECKJOY ( -- )
    1 IN  0= USEJOYSTICK !
;
    
: GETJOY ( -- )
    1 IN ( READ JOYSTICK )

    DUP 1 AND 0> IF ( CHECK FOR UP/ FORWARD )
	DROP 54
    ELSE
	DUP 4 AND 0> IF ( CHECK FOR RIGHT )
	    DROP 56
	ELSE
	    DUP 8 AND 0> IF ( CHECK FOR LEFT )
		DROP 53
	    ELSE ( OTHERWISE NO VALID MOVEMENT )
		DROP 0
	    THEN
	THEN
    THEN
;

: WAITKEY ( -- KEY )
    BEGIN
	INKEY 0=
    UNTIL

    BEGIN
	INKEY ?DUP
	IF
	    EXIT
	THEN

	USEJOYSTICK @ IF
	    GETJOY ?DUP
	    IF
		EXIT
	    THEN
	THEN
    0 UNTIL
;

( ON A 50 HZ COMPUTER, 1250 GETKEY ITERATIONS IS ROUGHLY 1 SEC )
( WITH JOYSTICK SUPPORT ENABLED, IT IS MORE LIKE 300 ITERATIONS PER SECOND ) 
: GETKEY ( ITER -- )
    0 DO
	INKEY
	?DUP IF ( A KEY HAS BEEN PRESSED, SO STORE IT )
	    LASTKEY !
	THEN

	USEJOYSTICK @ IF ( IF ACTIVE, CHECK JOYSTICK )
	    GETJOYSTICK ?DUP IF
		LASTKEY !
	    THEN
	THEN
    LOOP
;

: GETKEYW ( -- )
    ( CHECK NO KEY PRESSED TO START )
    BEGIN
	INKEY 0=
    UNTIL

    ( INFINITE LOOP UNTIL KEY IS PRESSED )
    BEGIN
	INKEY
	DUP IF
	    LASTKEY !
	    EXIT
	THEN

	USEJOYSTICK @ IF
	    GETJOY

	    DUP IF
		DUP LASTKEY !
	    THEN

	    OR ( MERGE KEYPRESS AND JOYSICK-MOVE TO CREATE FLAG ) 
	THEN
    UNTIL
;

: GR ( SEE MANUAL, P. 71 )
    8 * 11263 +
    DUP 8 +

    DO
	I C!
	-1
    +LOOP
;

: SETUPUDG
    ( 1 = CHEQUERBOARD )
    170 85 170 85 170 85 170 85
    1
    ( 2 = TOP WHITE, BOTTOM CHEQUERBOARD )
    0 0 0 0 170 85 170 85
    2
    ( 3 = TOP CHEQUERBOARD, BOTTOM WHITE )
    170 85 170 85 0 0 0 0 
    3
    GR
;

16 CONSTANT MAZEW
18 CONSTANT MAZEH
4 CONSTANT REXSPEED

0 CONSTANT _SPACE
8 CONSTANT _FOOTP
32 CONSTANT _REX
64 CONSTANT _EXIT
128 CONSTANT _WALL

( ALLOCATE SPACE FOR MAZE IN MEMORY )
CREATE MAZE MAZEW MAZEH * ALLOT

( DISPLAY MAZE ON-SCREEN, FOR DEBUGGING )
: PRINTMAZE ( -- )
    0 11 AT ." REX'S LAIR"

    MAZE ( PUT ADDRESS OF START OF MAZE ON STACK )

    MAZEH 0 DO ( STEP THROUGH ROWS )
	I 2 + 2 AT ( SET PRINT LOCATION FOR CURRENT ROW )
	MAZEW 0 DO ( STEP THROUGH COLUMNS )
	    ( RETRIEVE CELL DATA FOR LOCATION AND ADVANCE POINTER)
	    DUP 1+ SWAP C@
	    ( TRANSLATE INTO PRINTABLE CHARACTER )
	    CASE
		_WALL OF
		    1 EMIT
		ENDOF
		_SPACE OF
		    32 EMIT
		ENDOF
		_REX OF
		    [ ASCII M 128 + ] LITERAL EMIT
		ENDOF
		[ _REX _FOOTP + ] LITERAL OF
		    [ ASCII M 128 + ] LITERAL EMIT
		ENDOF
		_EXIT OF
		    [ ASCII E 128 + ] LITERAL EMIT
		ENDOF
		_FOOTP OF
		    58 EMIT
		ENDOF
		OTHERWISE
		    46 EMIT
	    ENDCASE
	LOOP
    LOOP

    DROP
;

( INITIALISE MAZE WITH ALL WALLS FILLED IN )
: CLEARMAZE ( -- )
    MAZE DUP MAZEW MAZEH * + SWAP
    DO
	_WALL I C! ( 128 IS CODE FOR WALL )
    LOOP
;

: MAZEGET ( X Y -- C )
    SWAP MAZEW * +
    MAZE +
    C@
;

: MAZESET ( X Y C -- )
    >R ( SAVE NEW VALUE )
    SWAP MAZEW * +
    MAZE +
    R>
    SWAP C!
;

: MOVENORTH ( X Y -- NX NY FLAG )
    SWAP
    DUP 0> IF
	1- SWAP 1
    ELSE
	SWAP 0
    THEN
;

( REMOVE ANY FOOTPRINTS FROM THE MAZE )
: RESETMAZE ( -- )
        MAZE DUP MAZEW MAZEH * + SWAP
    DO
	I C@ 247 AND I C! ( 128 IS CODE FOR WALL )
    LOOP
;


: MOVESOUTH ( X Y -- NX NY FLAG )
    SWAP
    DUP MAZEH 1- < IF
	1+ SWAP 1
    ELSE
	SWAP 0
    THEN
;

: MOVEEAST ( X Y -- NX NY FLAG )
    DUP MAZEW < IF
	1+ 1
    ELSE
	0 
    THEN
;

: MOVEWEST ( X Y -- NX NY FLAG )
    DUP 0> IF
	1- 1
    ELSE
	0 
    THEN
;

: TRYNORTH ( X Y -- NX NY FLAG )
    MOVENORTH ( ATTEMPT TO MOVE NORTH )

    0= IF ( IF FAIL, THEN EXIT )
	0 EXIT
    THEN

    2DUP MAZEGET ( RETRIEVE NEW-LOCATION STATUS )

    0= IF ( IF ALREADY A PASSAGE,  EXIT )
	1 EXIT
    THEN

    OVER 0= IF ( IF TOP OF THE MAZE, REVERSE AND EXIT )
	MOVESOUTH
	DROP
	0 EXIT
    THEN

    2DUP 1+ MAZEGET ( CHECK IF PASSAGE TO EAST OF NEW LOCATION )

    0= IF ( REVERSE AND EXIT, IF SO )
	MOVESOUTH
	DROP
	0 EXIT
    THEN

    2DUP 1- MAZEGET ( CHECK IF PASSAGE TO WEST OF NEW LOCATION )

    0= IF ( REVERSE AND EXIT, IF SO )
	MOVESOUTH
	DROP
	0 EXIT
    THEN

    2DUP _SPACE MAZESET ( ALL GOOD, SO EXTEND PASSAGE AND REPORT SUCCESS )
    1
;

: TRYSOUTH ( X Y -- NX NY FLAG )
    MOVESOUTH ( ATTEMPT TO MOVE SOUTH )

    0= IF ( IF FAIL, THEN EXIT )
	0 EXIT
    THEN

    2DUP MAZEGET ( RETRIEVE NEW-LOCATION STATUS )

    0= IF ( IF ALREADY A PASSAGE, THEN EXIT )
	1 EXIT
    THEN

    OVER 17 = IF ( IF BOTTOM OF THE MAZE, REVERSE AND EXIT )
	MOVENORTH
	DROP
	0 EXIT
    THEN

    2DUP 1+ MAZEGET ( CHECK IF PASSAGE TO EAST OF NEW LOCATION )

    0= IF ( REVERSE AND EXIT, IF SO )
	MOVENORTH
	DROP
	0 EXIT
    THEN

    2DUP 1- MAZEGET ( CHECK IF PASSAGE TO WEST OF NEW LOCATION )

    0= IF ( REVERSE AND EXIT, IF SO )
	MOVENORTH
	DROP
	0 EXIT
    THEN

    2DUP _SPACE MAZESET ( ALL GOOD, SO EXTEND PASSAGE AND REPORT SUCCESS )
    1
;

: TRYEAST ( X Y -- NX NY FLAG )
    MOVEEAST

    0= IF
	0 EXIT
    THEN

    2DUP MAZEGET

    0= IF
	1 EXIT
    THEN

    DUP
    15 = IF
	MOVEWEST
	DROP
	0 EXIT
    THEN

    OVER 1+ OVER MAZEGET

    0= IF
	MOVEWEST
	DROP
	0 EXIT
    THEN

    OVER 1- OVER MAZEGET

    0= IF
	MOVEWEST
	DROP
	0 EXIT
    THEN

    2DUP _SPACE MAZESET
    1
;

: TRYWEST ( X Y -- NX NY FLAG )
    MOVEWEST

    0= IF
	0 EXIT
    THEN

    2DUP MAZEGET

    0= IF
	1 EXIT
    THEN

    DUP
    0= IF
	MOVEEAST
	DROP
	0 EXIT
    THEN
    
    OVER 1+ OVER MAZEGET

    0= IF
	MOVEEAST
	DROP
	0 EXIT
    THEN

    OVER 1- OVER MAZEGET

    0= IF
	MOVEEAST
	DROP
	0 EXIT
    THEN

    2DUP _SPACE MAZESET
    1
;

: MAKEPASSAGE ( X Y DIR LEN -- NX NY )
    BEGIN
	>R ( SAVE LENGTH FOR LATER )

	DUP >R ( SAVE COPY OF DIRN FOR LATER )

	( EXTEND PASSAGE BASED ON VALUE OF DIRN )
	CASE
	    0 OF TRYNORTH ENDOF
	    1 OF TRYEAST ENDOF
	    2 OF TRYSOUTH ENDOF
	    3 OF TRYWEST ENDOF
	    OTHERWISE 0
	ENDCASE

	( RETRIEVE DIR AND LEN FROM RETURN STACK )
	R> R>

	( BRING STATUS TO TOP OF STACK AND TEST )
	ROT 0= IF ( ALL DONE )
	    DROP
	    DROP
	    EXIT
	THEN

	( OTHERWISE, DECREMENT LENGTH AND CHECK IF DONE )
	1-
	DUP
    0= UNTIL

    ( BALANCE STACK )
    DROP
    DROP
;

: CREATEMAZE ( -- )
    MAZEH 2- MAZEW 2- ( COORDINATES OF BOTTOM-RIGHT CORNER )

    2DUP 0 MAZESET ( CREATE START OF PASSAGE )
    
    0 ( COUNTER )
    BEGIN
	4 RND ( CHOOSE RANDOM DIRECTION )
	6 RND 1+ ( CHOOSE RANDOM LENGTH, 1..6 )

	ROT OVER + ( UPDATE COUNTER )
	>R ( SAVE COUNTER )

	MAKEPASSAGE

	R> ( RETRIEVE COUNTER )

	( CHECK IF DONE )
	DUP 800 >
    UNTIL
    
    DROP DROP DROP
;

: MAKEEXIT ( -- )
    0 0 ( DUMMY STACK ENTRIES )
    BEGIN
	DROP DROP ( CLEAR PREVIOUS ATTEMPT )

	( COMPUTE NEW RANDOM LOCATION IN TOP ONE THIRD OF MAZE )
	MAZEH 3 / RND 1+ 
	MAZEW 2- RND 1+
	
	2DUP MAZEGET ( RETRIEVE MAZE ELEMENT )
    0= UNTIL ( CONTINUE UNTIL FIND A PASSAGE )

    ( INSERT EXIT )
    2DUP 
    _EXIT MAZESET

    ( CHECK THERE IS ONLY ONE WAY TO GET TO EXIT )
    ( MAZE-GENERATION TECHNIQUE MEANS THERE MUST BE )
    ( AT LEAST ONE PATH )
    ( EX EY )

    ( RETRIEVE CELL VALUE TO NORTH )
    SWAP 1- SWAP MAZEGET

    ( IF PASSAGE, THEN SET FLAG TO CONFIRM NO MORE )
    0=

    >R ( STORE FLAG ON RETURN STACK )
    
    ( CHECK EAST )
    2DUP 1+
    MAZEGET

    ( IF PASSAGE, THEN CHECK IF THIS IS FIRST ONE )
    0= IF
	R> ( RETRIEVE FLAG FROM RETURN STACK )
	1 = IF
	    ( ALREADY A PASSAGE, SO MAKE THIS ONE A WALL )
	    2DUP 1+
	    _WALL MAZESET
	THEN
	
	( WHATEVER HAPPENED, THERE IS A PASSAGE )
	( AT THIS POINT )
	1 >R 
    THEN
    
    ( CHECK SOUTH )
    2DUP SWAP 1+ SWAP
    MAZEGET

    ( IF PASSAGE, THEN CHECK IF THIS IS FIRST ONE )
    0= IF
	R> ( RETRIEVE FLAG FROM RETURN STACK )
	1= IF
	    ( ALREADY A PASSAGE, SO MAKE THIS ONE A WALL )
	    2DUP SWAP 1+ SWAP
	    _WALL MAZESET
	THEN
	
	( WHATEVER HAPPENED, THERE IS A PASSAGE )
	( AT THIS POINT )
	1 >R
    THEN
    
    ( CHECK WEST )
    2DUP 1-
    MAZEGET

    0= IF
	R> ( RETRIEVE FLAG FROM RETURN STACK )
	1= IF
	    ( ALREADY A PASSAGE, SO MAKE THIS ONE A WALL )
	    2DUP 1-
	    _WALL MAZESET
	THEN
	
	( WHATEVER HAPPENED, THERE IS A PASSAGE )
	( AT THIS POINT )
	1 >R
    THEN

    ( CLEAR RETURN STACK AND BALANCE STACK )
    R> DROP
    DROP DROP
;

( VARIABLES TO HOLD LOCATION OF REX, DISTANCE FROM PLAYER, AND STEP )
0 VARIABLE REX_R
0 VARIABLE REX_C
( 0 VARIABLE REX_STEPS )
0 VARIABLE SCORE

-1 VARIABLE REXVIS ( INDICATES REX IS VISIBLE )

: PLACEREX ( -- )
    0 0 ( DUMMY COORDINATES TO START WITH )

    BEGIN
	DROP DROP
	MAZEH 4 / RND 1+
	MAZEW 2- RND 1+
	2DUP MAZEGET
    0= UNTIL

    2DUP

    REX_C !
    REX_R !
    
    _REX MAZESET
;

( COMPLETE STEPS TO SET UP NEW MAZE )
: SETUPMAZE ( -- )
  CLEARMAZE
  CREATEMAZE
  MAKEEXIT
  PLACEREX
;

: TURNLEFT ( DIR -- NEWDIR )
    3 +
    4 MOD
;

: TURNRIGHT ( DIR -- NEWDIR )
    1+
    4 MOD
;

: MOVE ( X Y DIR -- NX NY )
    DUP
    2 MOD IF
	2 -
	-
    ELSE
	1-
	ROT +
	SWAP
    THEN
;

: INCSCORE ( -- )
    SCORE @
    5 +
    SCORE !
;

: PRINTSCORE ( OFFSET -- )
    >R ( SAVE OFFSET )
    SCORE @ 00 ( MAKE DOUBLE-PRECISION )
    <# # # # # #> ( TRANSCRIBE TO PAD AS FOUR-DIGIT NUMBER )
    R> ( RETRIEVE OFFSET )
    FTYPE ( PRINT TO BUFFER )
;


( FIRST COL AT DISTANCE )
CREATE DISTCOL   0 C,  1 C,  4 C,  6 C,  8 C,  9 C, 10 C,

( MAX WALL HEIGHT AT DISTANCE )
CREATE DISTWALL  18 C, 12 C, 12 C, 12 C, 8 C, 8 C, 4 C, 4 C, 2 C,  1 C,

: DRAWLWALL ( COL FLAG -- )
    OVER BUFFER +

    SWAP ( COL ADDR FLAG )

    IF ( WALL )
	OVER ?DUP IF
	    0 DO
		32 OVER C!
		32 +
	    LOOP
	THEN

	145 OVER C!
	32 +

	OVER -2 * 18 +

	?DUP IF
	    0 DO
		144 OVER C!
		32 +
	    LOOP
	THEN

	140 OVER C!
	32 +

	OVER ?DUP IF
	    0 DO
		32 OVER C!
		32 +
	    LOOP
	THEN
    ELSE
	SWAP
	DISTWALL + C@
	SWAP
	OVER 20 SWAP - 2 /

	?DUP IF
	    0 DO
		32 OVER C!
		32 +
	    LOOP
	THEN

	OVER 0 DO
	    1 OVER C!
	    32 +
	LOOP

	OVER 20 SWAP - 2 /
	?DUP IF
	    0 DO
		32 OVER C!
		32 +
	    LOOP
	THEN
    THEN

    DROP
    DROP
;

: DRAWRWALL ( COL FLAG -- )
    OVER BUFFER 20 + SWAP - SWAP

    IF ( WALL )
	OVER ?DUP IF
	    0 DO
		32 OVER C!
		32 +
	    LOOP
	THEN

	146 OVER C!
	32 +

	OVER -2 * 18 +

	?DUP IF
	    0 DO
		144 OVER C!
		32 +
	    LOOP
	THEN

	23 OVER C!
	32 +

	OVER ?DUP IF
	    0 DO
		32 OVER C!
		32 +
	    LOOP
	THEN
    ELSE
	SWAP
	DISTWALL + C@
	SWAP
	OVER 20 SWAP - 2 /

	?DUP IF
	    0 DO
		32 OVER C!
		32 +
	    LOOP
	THEN

	OVER 0 DO
	    1 OVER C!
	    32 +
	LOOP

	OVER 20 SWAP - 2 /
	?DUP IF
	    0 DO
		32 OVER C!
		32 +
	    LOOP
	THEN
    THEN

    DROP
    DROP
;
	
( LOOK UP TABLE FOR WIDTH OF END WALL AT DIFFERENT DISTANCES )
CREATE DISTWIDTH 21 C, 19 C, 13 C, 9 C, 5 C, 3 C, 1 C,

( LOOK UP TABLE FOR HEIGHT OF END WALL AT DIFFERENT DISTANCES )
CREATE DISTHEIGHT 20 C, 18 C, 12 C, 8 C, 4 C, 2 C, 2 C, 

: DRAWEWALL ( DIST -- )
    DUP ( SAVE COPY OF DISTANCE )
    DISTWIDTH + C@ ( RETRIEVE WIDTH OF END WALL )
    21 OVER - 2 / >R ( WORK OUT AND SAVE OFFSET FROM LEFT )
    SWAP ( RETRIEVE SAVED COPY OF DIST )
    DISTHEIGHT + C@ ( RETRIEVE WALL HEIGHT )
    20 OVER - 2 / ( WORK OUT OFFSET FROM TOP )
    32 * ( TURN IT INTO A ROW OFFSET )
    BUFFER + R> + ( DISPLACE FROM BEGINNING OF DISPLAY BUFFER )

    SWAP 0 DO ( FOR EACH ROW )
	DUP

	3 PICK 0 DO ( FOR EACH COLUMN )
	    1 OVER C!
	    1+
	LOOP

	DROP
	32 +
    LOOP

    ( BALANCE STACK )
    DROP 
    DROP
;

: DRAWLSEG ( DIST FLAG -- )
    >R ( SAVE FLAG )
    DUP DISTCOL + 1+ C@ ( COMPUTE UPPER BOUND ON LOOP )
    SWAP DISTCOL + C@ ( COMPUTE LOWER BOUND ON LOOP )
    DO ( DRAW EACH WALL SEGMENT )
	I J DRAWLWALL
    LOOP

    R> DROP ( RETRIEVE FLAG AND DROP )
;

: DRAWRSEG ( DIST FLAG -- )
    >R ( SAVE FLAG ) 
    DUP DISTCOL + 1+ C@ ( COMPUTE UPPER BOUND ON LOOP )
    SWAP DISTCOL + C@ ( COMPUTE LOWER BOUND ON LOOP )
    DO ( DRAW EACH WALL SEGMENT )
	I J DRAWRWALL
    LOOP

    R> DROP ( RETRIEVE FLAG AND DROP )
;

CREATE 3DVIEW 4096 ALLOT ( SPACE FOR 3D RENDERER M/CODE )

0 VARIABLE EXITVIS ( INDICATES EXIT IS VISIBLE )
0 VARIABLE REXMOVED ( INDICATES THAT REX HAS MOVED, WHEN CAN )
0 VARIABLE PLMOVED ( INDICATES FRAME NEEDS UPDATED )

( PART M/CODE VERSION )
: DRAWVIEW ( X Y DIR -- )
    [ 3DVIEW ] LITERAL CALL
;

( PURE-ISH FORTH VERSION OF 3D VIEWER )
: DRAWVIEWF ( X Y DIR -- )
    -1 EXITVIS ! ( ASSUME EXIT IS NOT VISIBLE )
    -1 REXVIS ! ( ASSUME REX IS NOT VISIBLE )
    
    0 ( START AT DISTANCE 0 )
    
    BEGIN
	>R ( SAVE CURRENT DISTANCE )

	( PRINT LEFT WALL SEGMENT )
	3DUP TURNLEFT MOVE MAZEGET
	_WALL = I SWAP DRAWLSEG

	( PRINT RIGHT WALL SEGMENT )
	3DUP TURNRIGHT MOVE MAZEGET
	_WALL = I SWAP DRAWRSEG

	( .S : X Y DIR )

	( MOVE FORWARD )
	DUP >R MOVE R>

	( CHECK FOR WALL )
	3 PICK 3 PICK MAZEGET

	( ISOLATE WALL AND EXIT PATTERNS ONLY )
	[ _EXIT _WALL OR ] LITERAL AND 
	
	DUP _EXIT = IF
	    I 1+
	    EXITVIS !
	    DROP 1
	ELSE _WALL = DUP ( .S : X Y DIR FLAG1 )
	    IF
		( IF END WALL, THEN DRAW )
		I 1+ DRAWEWALL
	    THEN
	THEN
	    
	R> 1+ DUP 6 =
	ROT

	( IF HAVE REACHED END WALL OR DISTANCE 6 WE ARE DONE )
	OR	
    UNTIL

    ( .S NX NY DIR DIST )

    ( CHECK IF GOT TO FULL DISTANCE )
    6 = IF
	DROP
	MAZEGET

	_WALL = IF
	    _TOPWHITEBOTTOMCHEQUER BUFFER 298 + C!
	    _TOPCHEQUERBOTTOMWHITE BUFFER 330 + C!
	ELSE
	    _BOTTOMBLACK BUFFER 298 +  C!
	    _TOPBLACK BUFFER 330 +  C!
	THEN
    ELSE
	DROP
	DROP
	DROP
    THEN
;

( CYCLE EXIT PATTERN )
: CYCLEPAT 
    [ 3DVIEW 06 + ] LITERAL CALL ( SHIFT CHARACTERS DOWN IN MEMORY BY ONE )

    ( ADD NEW CHARACTER TO END OF PATTERN )
    32 96 RND + ( PRINTABLE CHARACTERS ARE BETWEEN 32 AND 127 )
    2 RND 128 * +  ( PLUS OPTION TO INVERT CHARACTER )
    SWAP C!
;

( DETERMINE DISTANCE TO REX )
: REXDIST ( X Y D -- )
    -1 REXVIS ! ( ASSUME REX IS NOT VISIBLE )

    0 ( INITIAL DISTANCE TO CHECK )
    BEGIN
	>R ( SAVE CURRENT DISTANCE )

	3PICK 3PICK MAZEGET ( CHECK CURRENT LOCATION )

	DUP _WALL = IF ( HAVE REACHED A WALL WITHOUT FINDING REX )
	    DROP
	    R> DROP 5 >R ( SET DISTANCE TO MAX )
	ELSE
	    _REX = IF ( FOUND MONSTER )
		R>
		DUP REXVIS ! ( STORE IT )
		5 >R ( SET DISTANCE TO MAX )
	    THEN
	THEN

	>R I MOVE R> ( MOVE TO NEXT SQUARE )
	
	R> ( RETRIEVE COUNTER AND UPDATE )
	1+ 

	DUP 6 = ( CHECK IF WE ARE DONE )
    UNTIL

    DROP DROP DROP DROP ( BALANCE STACK )
;

: ATEXIT ( -- )
    2 FRAMECLEAR
    [ 32 5 * 22 + ] LITERAL PRINTSCORE
    
    30 0 DO
	0 [ 3DVIEW 3 + ] LITERAL CALL
	CYCLEPAT
	FRAMEUPDATE

	10 0 DO
	    HALT
	LOOP
    LOOP
;

( INITIALISE GAME )
: INITGAME ( -- )
    1 PLMOVED ! ( NEED TO REDRAW FRAME )
    -1 EXITVIS ! ( ASSUME EXIT NOV VISIBLE )
    -1 REXVIS ! ( ASSUME REX NOT INITIALLY VISIBLE )
    1 REXMOVED ! ( ASSUME REX CAN MOVE )
   8 STATUSCNT ! ( SET STATUS TIMEOUT TO MAXIMUM )
   0 STATUSMSG ! ( START WITH "REX LIES IN WAIT" )
    
    0 [ 3DVIEW 24 + ] LITERAL C! ( REX STARTS ON RIGHT FOOT )
;

: CHECKCAUGHT ( PR PC -- FLAG )
    REX_C @ = IF ( COMPARE TO REX COL VALUE )
	REX_R @ = IF
	    [ 3DVIEW 24 + ] LITERAL C@ 2 AND
	    IF
		1
	    ELSE
		0
	    THEN
	ELSE
	    0
	THEN
    ELSE
	DROP
	0
    THEN
;
    
: TEST
    1 FRAMECLEAR ( CLEAR FRAME BUFFER )
    INITGAME

    ( STARTING POSITION FOR TEST )
    MAZEH 2- MAZEW 2- 3 ( BOTTOM-RIGHT CORNER, FACING WEST )

    BEGIN
	( CHECK IF NEED TO UPDATE VIEW )
	PLMOVED @ IF
	    1 FRAMECLEAR
	    STATUSMSG @ PRINTSTATUS
	    [ 11 32 * 23 + ] LITERAL PRINTSCORE
	    3DUP DRAWVIEW
	    FRAMEUPDATE
	    0 PLMOVED !
	THEN

	( CHECK IF NEED TO UPDATE AND REDRAW EXIT )
	EXITVIS @ ( -1 MEANS NOT VISIBLE )
	1+ ?DUP IF
	    1-
	    [ 3DVIEW 3 + ] LITERAL CALL ( REDRAW EXIT )
	    CYCLEPAT
	    FRAMEUPDATE ( PUSH TO DISPLAY )
	THEN

	( MOVE REX )
	3 PICK 3 PICK MOVEREX
	
	( CHECK IF REX IS VIISIBLE AND, IF SO, DRAW HIM )
	3DUP REXDIST
	REXVIS @ 1+ ?DUP IF
	    1- [ 3DVIEW 9 + ] LITERAL CALL ( DRAW REX )
	    6 PRINTSTATUS ( CLEAR STATUS MESSAGE )
	    FRAMEUPDATE
	ELSE
	    3DUP SETSTATUS
	    STATUSMSG @ PRINTSTATUS
	    FRAMEUPDATE
	THEN
	
	( CHECK IF PLAYER CAUGHT )
	3 PICK 3 PICK CHECKCAUGHT
	IF 
	    0 FRAMECLEAR
	    0 [ 3DVIEW 9 + ] LITERAL CALL
	    [ 7 32 * ] LITERAL PRINTSCORE
	    FRAMEUPDATE
	    WAITKEY DROP
	    EXIT
	THEN
	
	( READ KEYBOARD, USING A LOOP TO SLOW DOWN GAME AND MAKE IT )
	( MORE RESPONSIVE )
	20 0 DO
	    INKEY
	    ?DUP IF
		CASE
		    53 OF ( '6' - TURN LEFT )
			TURNLEFT
			1 PLMOVED ! ( SIGNAL FOR FRAME REDRAW )
		    ENDOF
		    
		    56 OF ( '9' - TURN RIGHT )
			TURNRIGHT
			1 PLMOVED ! ( SIGNAL FOR FRAME REDRAW )
		    ENDOF
		    
		    54 OF ( '8' - MOVE FORWARD )
			3DUP MOVE MAZEGET
			160 and 0= IF ( CHECK THAT IS NOT A WALL )
			    >R I MOVE R>
			    INCSCORE
			THEN
			1 PLMOVED ! ( SIGNAL FOR FRAME REDRAW )
		    ENDOF
		    
		    OTHERWISE
		    ( OTHER KEYPRESSES CURRENTLY IGNORED )
		ENDCASE
		LEAVE
	    THEN
	LOOP
		    
	( CHECK IF REACHED EXIT )
	3 PICK 3 PICK MAZEGET
	_EXIT = IF
	    ATEXIT
	    WAITKEY DROP
	    EXIT
	THEN
	
	0 ( INFINITE LOOP )
    UNTIL
;

    
: SGN ( NUM -- SIGN )
    DUP 0> IF
	DROP
	1
    ELSE
	0< IF
	    -1
	ELSE
	    0
	THEN
    THEN
;

: MOVEREXEW ( DC -- )
    SGN ( WORK OUT DIRECTIN )
    >R ( STORE IT )
    
    ( RETRIEVE REX'S LOCATION )
    REX_R @
    REX_C @

    ( DUPLICATE AND APPLY MOVE )
    2DUP
    R> +

    ( .S : R C NR NC )

    ( CHECK IF VALID MOVE )
    2DUP MAZEGET

    192 AND IF ( EXIT OR WALL )
	DROP DROP
	DROP DROP
    ELSE ( PATH IS CLEAR )
	2DUP ( STORE NEW LOCATION )
	REX_C ! 
	REX_R !

	( UPDATE MAZE )
	2DUP MAZEGET _REX OR MAZESET
	2DUP MAZEGET [ 255 _REX - ] LITERAL AND _FOOTP OR MAZESET
	0 [ 3DVIEW 24 + ] LITERAL C! ( RESET STEP TIMER )
    THEN
;

: MOVEREXNS ( DR -- )
    SGN ( WORK OUT DIRECTION )
    >R ( STORE IT )
    
    ( RETRIEVE REX'S LOCATION )
    REX_R @
    REX_C @

    ( DUPLICATE AND APPLY MOVE )
    2DUP
    SWAP R> + SWAP

    ( .S : R C NR NC )

    ( CHECK IF VALID MOVE )
    2DUP MAZEGET

    192 AND IF ( EXIT OR WALL )
	DROP DROP
	DROP DROP
    ELSE ( PATH IS CLEAR )
	2DUP ( STORE NEW LOCATION )
	REX_C ! 
	REX_R !

	( UPDATE MAZE )
	2DUP MAZEGET _REX OR MAZESET
	2DUP MAZEGET [ 255 _REX - ] LITERAL AND _FOOTP OR MAZESET
	0 [ 3DVIEW 24 + ] LITERAL C! ( RESET STEP TIMER )
    THEN
;

8 VARIABLE STATUSCNT
0 VARIABLE STATUSMSG

: MOVEREX ( PR PC -- )
    1 REXMOVED ! ( ASSUME REX CAN MOVE )
    ( UPDATE STEP COUNTER )
    [ 3DVIEW 24 + ] LITERAL C@ ( RETRIEVE THE STEP COIUNTER )
    1+

    DUP REXSPEED > IF
	1-
    THEN

    ( SAVE STEP COUNTER )
    DUP [ 3DVIEW 24 + ] LITERAL  C!

    ( CHECK IF REX SHOULD MOVE )
    REXSPEED < IF
	DROP DROP
	EXIT
    THEN

    ( COMPUTE DELTAS BETWEEN PLAYER AND REX )
    REX_C @ - ( COLUMN DELTA FIRST )
    >R ( SAVE COLUMN DELTA )
    REX_R @ - ( COMPUTE ROW DELTA )
    R> ( RESTORE COLUMN DELTA )

    ( .S: DELTA_R DELTA_C )
    2DUP ( CREATE COPY )
    OVER ABS OVER ABS ( EXTRACT MAGNITUDES )

    < IF ( DELTA_C > DELTA_R )
	MOVEREXEW
	DROP
    ELSE 
	DROP
	DUP IF ( CHECK DELTA_R IS NON-ZERO )
	    MOVEREXNS
	ELSE
	    DROP
	THEN
    THEN

    ( RETRIEVE STEP COUNTER )
    [ 3DVIEW 24 + ] LITERAL C@

    0= IF ( INDICATES REX HAS MOVED )
	DROP DROP
	EXIT
    THEN

    ( OTHERWISE TRY OTHER DELTA )
    OVER ABS OVER ABS

    < IF
	DROP

	DUP IF ( CHECK DELTA_R IS NON-ZERO )
	    MOVEREXNS
	ELSE
	    DROP
	THEN
    ELSE
	DUP IF ( CHECK DELTA_C IS NON-ZERO )
	    MOVEREXEW
	ELSE
	    DROP
	THEN

	DROP
    THEN

    ( RETRIEVE STEP COUNTER )
    [ 3DVIEW 24 + ] LITERAL C@ IF ( REX COULD NOT MOVE )
	0 REXMOVED !
    THEN
;

( CHECK REX GRAPHICS )
: TEST2
    ( START ON RIGHT FOOT )
    0 [ 3DVIEW 24 + ] LITERAL C!

    0 FRAMECLEAR

    6 0 DO
	( RIGHT FOOT )
	5 I - [ 3DVIEW 9 + ] LITERAL CALL
	FRAMEUPDATE

	WAITKEY DROP

	( CHANGE FOOT )
	[ 3DVIEW 24 + ] C@
	2 XOR
	[ 3DVIEW 24 + ] C!

	( LEFT FOOT )
	5 I -
	[ 3DVIEW 9 + ] LITERAL CALL
	FRAMEUPDATE
	WAITKEY DROP

	( CHANGE FOOT )
	[ 3DVIEW 24 + ] C@
	2 XOR
	[ 3DVIEW 24 + ] C!
    LOOP
;

( CHECK IF REX IS IN LINE OF SIGHT OF PLAYER, TO DISTANCE )
( SPECIFIED. PR AND PC ARE PLAYER COORDS, DIR IS DIRECTION )
( TO CHECK AND DIST IS DISTANCE TO CHECK TO )
: SIGHTREX ( PR PC DIR DIST -- FLAG )
    0 ( DUMMY CELL CONTENTS FOR FIRST ITERATION )

    SWAP 0 DO ( CHECK TO DISTANCE )
	DROP ( PREVIOUS CELL CONTENTS )
	>R I ( COPY DIRECTION TO RETURN STACK )
	MOVE ( MOVE ONE STEP )
	2DUP MAZEGET ( RETRIEVE CELL VALUE )
	R> SWAP ( RETRIEVE DIRECTION AND BALANCE STACK )
	[ _WALL _REX _EXIT + + ] LITERAL AND IF ( CHECK FOR WALL/ EXIT/ REX )
	    LEAVE
	THEN ( OTHERWISE CONTINUE )
    LOOP

    ( .S : PR PC PD VALUE )
    >R
    DROP DROP DROP
    R>

    _REX = ( IS IT REX? )
;

( COMPUTE DISTANCE FROM PLAYER TO REX AND WHETHER )
( REX IS IN LINE OF SIGHT. ON EXIT, DIR = -1 IF NOT )
: FINDREX ( PR PC -- DIR DIST )
    2DUP ( STORE PLAYER LOCATION )

    ( RETRIEVE REX'S LOCATION AND COMPUTE DELTAS )
    REX_C @ -
    SWAP
    REX_R @ -
    SWAP
    
    ( .S : PR PC DELTA_R DELTA_C )

    ( WORK OUT DISTANCE )
    OVER ABS OVER ABS +

    ( SAVE DIST )
    >R

    ( CHECK IF INLINE )
    ?DUP 0= IF ( REX IS INLINE VERTICALLY )
	0> IF ( REX IS NORTH OF PLAYER )
	    0 I SIGHTREX 1 = IF 0 ELSE -1 THEN
	ELSE ( REX IS SOUTH OF PLAYER )
	    2 I SIGHTREX 1 = IF 2 ELSE -1 THEN
	THEN
    ELSE
	SWAP 0= IF ( REX IS INLINE HORIZONTALLY )
	    0> IF ( REX IS WEST OF PLAYER )
		3 I SIGHTREX 1 = IF 3 ELSE -1 THEN
	    ELSE ( REX IS EAST OF PLAYER )
		1 I SIGHTREX 1 = IF 1 ELSE -1 THEN
	    THEN
	ELSE
	    DROP DROP ( DROP PLAYER COORDINATES )
	    DROP ( DROP DELTA_C )
	    -1 ( REX IS NOT INLINE WITH PLAYER )
	THEN
    THEN

    ( RESTORE DISTANCE )
    R>
;


( CODES FOR STATUS MESSAGES )
( 0 - REX LIES IN WAIT )
( 1 - <INV>RUN</INV> HE IS BEHIND YOU )
( 2 - <INV>RUN</INV> HE IS BESIDE YOU )
( 3 - REX HAS SEEN YOU )
( 4 - FOOTSTEPS APPROACHING )
( 5 - HE IS HUNTING YOU )
( 6 - <BLANK MESSAGE> )
: SETSTATUS ( PR PC PD -- )
    ( CHECK IF REX HAS MOVED )
    REXMOVED @ IF
	ROT ROT
	FINDREX

	( .S : PD DIR DIST )

	DUP 8 > IF
	    DROP DROP DROP

	    ( CHECK IF TIME TO CLEAR MESSAGE )
	    STATUSCNT @
	    ?DUP 0= IF
		6 STATUSMSG ! ( CLEAR MESSAGE )
	    ELSE
		1- STATUSCNT !
		5 STATUSMSG ! ( REX IS HUNTING YOU )
	    THEN
	ELSE
	    DUP 6 > IF
		DROP DROP DROP
		4 STATUSMSG ! ( FOOTSTEPS APPROACHING )
	    ELSE
		DUP 1 > IF ( REX NOT RIGHT NEXT TO PLAYER )
		    DROP
		    -1 = IF
			DROP
			4 STATUSMSG ! ( FOOTSTEPS APPROACHING )
		    ELSE
			DROP
			3 STATUSMSG ! ( REX HAS SEEN YOU )
		    THEN
		ELSE ( REX IS NEXT TO PLAYER )
		    DROP
		    + 1 AND IF
			2 STATUSMSG ! ( RUN, REX IS BESIDE YOU )
		    ELSE
			1 STATUSMSG ! ( RUN REX IS BEHIND YOU )
		    THEN
		THEN
	    THEN
	THEN
    ELSE
	DROP DROP DROP

	( CHECK COUNTER )
	STATUSCNT @
	DUP 8 < IF
	    1+
	    STATUSCNT !
	ELSE
	    DROP
	THEN
	
	0 STATUSMSG ! ( REX LIES IN WAIT )
	50 GETKEY
    THEN
;

: PRINTSTATUS ( CODE -- )
    22 * [ 3DVIEW 25 + ] LITERAL + ( FIND ADDR OF MESSAGE )
    22 ( ALL MESSAGES ARE SAME LENGTH )
    640 ( BEGINNING OF ROW 20 )
    FTYPE 
;

: CMOVE ( SRC DEST CNT -- )
    0 DO
	OVER C@
	OVER C!
	1+ SWAP
	1+ SWAP
    LOOP

    DROP DROP
;


: RINGMASTER ( ADDR ROWS -- )
    2400 SWAP 0 DO
	OVER OVER 10 CMOVE
	SWAP 10 +
	SWAP 32 +
    LOOP

    DROP DROP
;

: RMPRINT ( -- )
    21202 21 RINGMASTER ( ADDRESS CORRESPONDS TO RING_MASTER IN 3DVIEW )
;

    
: RMSTAND ( -- )
    21202 13 RINGMASTER ( ADDRESS CORRESPONDS TO RING_MASTER IN 3DVIEW )
;

    
: RMBOW ( -- )
    21422 13 RINGMASTER ( ADDRESS CORRESPONDS TO RING_M_BOW IN 3DVIEW )
;

    

( SCROLL MESSAGE WINDOW - RELOCATABLE)
CODE SCROLLWIN
    0x21 C, 0x2A C, 0x24 C, ( ld hl, #242a )
    0x11 C, 0x0A C, 0x24 C, ( ld de, #240a )
    0x06 C, 0x14 C,         ( ld b, #14 )
    0xc5 C,                 ( push bc )
    0x01 C, 0x16 C, 0x00 C, ( ld bc, $0016 )
    0xed C, exb0 C,         ( ldir )
    0x01 C, 0x0A C, 0x00 C, ( ld bc, $000A )
    0x09 C,                 ( add hl, bc )
    0xEB C,                 ( ex de, hl )
    0x09 C,                 ( add hl, bc )
    0xEB C,                 ( ex de, hl )
    0xC1 C,                 ( pop bc )
    0x10 C, 0xF0 C,         ( djnz -$10 )
    0xFD C, 0xE9 C,         ( jp <iy> )

CREATE INSTRUCTIONS  1526 ALLOT
	
: PRINTINST ( ADDR CNT -- )
    9866 SWAP 0 DO
	OVER OVER 22 CMOVE
	SWAP 22 + SWAP 
	28 PAUSE
	SCROLLWIN
	20 10 AT 22 SPACES
	26 PAUSE
	SCROLLWIN
    LOOP

    DROP DROP
;

: SCROLLINST ( CNT -- )
    0 DO
	SCROLLWIN
	30 PAUSE
    LOOP
;

: PLAYMAZE
    INITGAME

    ( STARTING POSITION FOR TEST )
    MAZEH 2- MAZEW 2- 3 ( BOTTOM-RIGHT CORNER, FACING WEST )

    ( DISPLAY MAZE VIEW, BUT WAIT FOR KEYPRESS )
    1 FRAMECLEAR
    STATUSMSG @ PRINTSTATUS
    [ 11 32 * 23 + ] LITERAL PRINTSCORE
    3DUP DRAWVIEW
    FRAMEUPDATE

    GETKEYW ( GAME DOESN'T START UNTIL KEY IS PRESSED )
    
    BEGIN
	( CHECK IF NEED TO UPDATE VIEW )
	PLMOVED @ IF
	    1 FRAMECLEAR
	    STATUSMSG @ PRINTSTATUS
	    [ 11 32 * 23 + ] LITERAL PRINTSCORE 
	    3DUP DRAWVIEW
	    FRAMEUPDATE
	    0 PLMOVED !
	ELSE
	    ( ARTIFICIAL WAIT TO MAKE TIMING MORE CONSISTENT )
	    GETKEYCNT @ GETKEY
	THEN

	( CHECK IF NEED TO UPDATE AND REDRAW EXIT )
	EXITVIS @ ( -1 MEANS NOT VISIBLE )
	1+ ?DUP IF
	    1-
	    [ 3DVIEW 3 + ] LITERAL CALL ( REDRAW EXIT )
	    CYCLEPAT
	    FRAMEUPDATE ( PUSH TO DISPLAY )
	THEN

	( MOVE REX )
	3 PICK 3 PICK MOVEREX
	
	( CHECK IF REX IS VIISIBLE AND, IF SO, DRAW HIM )
	3DUP REXDIST
	REXVIS @ 1+ ?DUP IF
	    1- [ 3DVIEW 9 + ] LITERAL CALL ( DRAW REX )
	    6 PRINTSTATUS ( CLEAR STATUS MESSAGE )
	    FRAMEUPDATE
	    GETKEYCNT @ 2 / GETKEY
	ELSE
	    3DUP SETSTATUS
	    STATUSMSG @ PRINTSTATUS
	    FRAMEUPDATE
	THEN
	
	( CHECK IF PLAYER CAUGHT )
	3 PICK 3 PICK CHECKCAUGHT
	IF ( GOT CAUGHT )
	    0 FRAMECLEAR
	    0 [ 3DVIEW 9 + ] LITERAL CALL
	    [ 12 32 * ] LITERAL PRINTSCORE
	    FRAMEUPDATE
	    DROP DROP DROP ( BALANCE STACK )
	    0 ( INDICATES FAILED TO COMPLETE GAME )
	    EXIT
	THEN
	
	( READ KEYBOARD, USING A LOOP TO SLOW DOWN GAME AND MAKE IT )
	( MORE RESPONSIVE )
	GETKEYCNT @ GETKEY
	CASE
	    53 OF ( '6' - TURN LEFT )
		TURNLEFT
		1 PLMOVED ! ( SIGNAL FOR FRAME REDRAW )
	    ENDOF
	    
	    56 OF ( '9' - TURN RIGHT )
		TURNRIGHT
		1 PLMOVED ! ( SIGNAL FOR FRAME REDRAW )
	    ENDOF
	    
	    54 OF ( '8' - MOVE FORWARD )
		3DUP MOVE MAZEGET
		( CHECK THAT IS NOT A WALL NOR REX )
		[ _WALL _REX + ] LITERAL AND 0= IF
		    ( CHECK REX IS NOT AT SAME LOCATION AS PLAYER )
		    3 PICK 3 PICK MAZEGET _REX AND 0= IF
			>R I MOVE R>
			INCSCORE
			1 PLMOVED ! ( SIGNAL FOR FRAME REDRAW )
		    THEN
		THEN
	    ENDOF
	    
	    63 OF ( '?' - PRINT MAZE )
		CLS PRINTMAZE
		( AND HIGHLIGHT PLAYER LOCATION )
		DROP
		3 PICK 2+ 3 PICK 2+ AT
		208 EMIT ( 208 = INV_P )
	    ENDOF
	    
	    OTHERWISE
	ENDCASE

	0 LASTKEY !
	
	( CHECK IF REACHED EXIT )
	3 PICK 3 PICK MAZEGET
	_EXIT = IF
	    SCORE @ 200 + SCORE !
	    ATEXIT
	    CLS
	    DROP DROP DROP ( BALANCE THE STACK )
	    1 ( INDICATES SUCCESS )
	    EXIT
	THEN
	
	0 ( INFINITE LOOP )
    UNTIL
;

: PLAYAGAIN ( -- FLAG )
    -1 ( DUMMY INITIAL VALUE )
    
    BEGIN
	DROP ( PREVIOUS KEY PRESS )

	WAITKEY 223 AND ( READ KEYBOARD AND CONVERT TO UPPER CASE )

	CASE
	    ASCII C OF
		1
	    ENDOF

	    ASCII A OF
		CLS
		10 10 AT ." APPEAL"
		2 RND IF
		    12 10 AT ." REJECTED"
		    50 PAUSE
		    1
		ELSE
		    12 10 AT ." ACCEPTED"
		    50 PAUSE
		    0
		THEN
	    OTHERWISE
		-1
	ENDCASE

	DUP 1+ ( CHECK IF VALID KEY PRESS AND REPEAT IF NOT )
    UNTIL
;		

: INTRO ( -- KEY )
    ( ENSURE NO KEY BEING PRESSED )
    BEGIN
	INKEY
	0=
    UNTIL

    9 7 AT ." ANYONE OUT THERE?"

    0
    
    BEGIN
	1+
	DUP 5000 =

	IF 
	    11 3 AT ." WELL PRESS SOMETHING THEN."
	THEN

	INKEY

	?DUP
    UNTIL

    SWAP DROP
;

( ENTRY POINT TO GAME )
: 3DMM
    CHECKJOY ( CHECK FOR PRESENCE OF JOYSTICK INTERFACE )

    ( SET GAME TIMING ACCORDINGLY )
    50 40 USEJOYSTICK @ * - GETKEYCNT !

    SETUPUDG
    
    CLS 37 PAUSE INTRO

    0 RAND ( RANDOMIZE GAME )

    CLS

    110 - IF ( CHECK FOR SKIP-INSTRUCTIONS )
	RMPRINT
	INSTRUCTIONS 29 PRINTINST

	RMBOW
	7 SCROLLINST

	BEGIN
	    WAITKEY 223 AND ( CONVERT LOWER CASE TO CAPITAL )

	    CASE
		ASCII K OF
		    RMSTAND
		    INSTRUCTIONS 638 + 32 PRINTINST
		    RMBOW
		    14 PAUSE 8 SCROLLINST
		    1
		ENDOF
		
		ASCII C OF
		    1
		ENDOF
		
		ASCII A OF
		    CLS
		    EXIT
		ENDOF
		
		OTHERWISE
		0
	    ENDCASE
	UNTIL
    THEN
	
    ( MAIN GAME LOOP )
    BEGIN
	0 SCORE !
	RMPRINT
	INSTRUCTIONS 1342 + 7 PRINTINST
	RMBOW
	3 SCROLLINST

	CLS

	FAST
	SETUPMAZE
	SLOW

	CLS

	BEGIN
	    0 LASTKEY !
	    PLAYMAZE

	    DUP 0= IF
		PLAYAGAIN
		0= IF
		    CLS
		    EXIT
		THEN

		0 SCORE !
		RESETMAZE
		REX_R @	REX_C @
		2DUP MAZEGET 223 AND
		MAZESET

		PLACEREX
	    THEN
	UNTIL

	0
    UNTIL
;
