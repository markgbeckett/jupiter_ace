( LIST OF NEW WORDS, AS CONFIRMED BY 'VLIST' :- CLEARTRAIL .S DEM RUN INSTRS MAN STEP LR UD WAIT AUTO CHOICE RT LT DN UP MOUSE SRAM DRAW PATH DOOR MOVE SCAN X+ X- Y+ Y- SP XP YP PP PSET RAM SCR PRINT CLEAR IU IV IX OU OV OX P1 P T U V W X Y Z RND SEED GR G D )

( MEMORY LAYOUT FOR MAZE STATUS IS, AS FOLLOWS:          )
( STARTS FROM [HERE + 30]                                )
( BITS SET HAVE FOLLOWING MEANING:                       )
(  0 - CAN MOVE RIGHT FROM THIS CELL                     )
(  1 - CAN MOVE LEFT FROM THIS CELL                      )
(  2 - CAN MOVE UP FROM THIS CELL                        )
(  3 - CAN MOVE DOWN FROM THIS CELL                      )
(  4 - HAS BEEN VISITED DURING AUTO-SOLVER MODE          )
(  5 - WITH BIT 6, HOLDS BREADCRUMB TRAIL                )
(      00 - ARRIVED FROM LEFT                            )
(      01 - ARRIVED FROM RIGHT                           )
(      10 - ARRIVED FROM ABOVE                           )
(      11 - ARRIVED FROM BELOW                           )
(  7 - CELL HAS BEEN VISITED, DURING MAZE GENERATION     )
(                                                        )
(                                                        )
( INITIALISED AS FOLLOWS                                 )
( <---       32x         --->                            )
( 00 00 ...                00                            )
( 00 00 ...                00                            )
( ...                     ...   21x                      )
( 00 00 ...                00                            )
( [VARIABLES P AND P1 POINT HERE]                        )
( 01 01 ...             01 03                            )
( 01 01 ...             01 03                            )
( ...                     ...   20x                      )
( 01 01 ...             01 03                            )
( 02 02 ...             02 04                            )

CREATE G ( ARRAY TO HOLD BITMAPS FOR 12 UDGS )
255 C, 128 C, 128 C, 128 C, 128 C, 128 C, 128 C, 128 C,
255 C,   0 C,   0 C,   0 C,   0 C,   0 C,   0 C,   0 C, 
128 C, 128 C, 128 C, 128 C, 128 C, 128 C, 128 C, 128 C, 
128 C,   0 C,   0 C,   0 C,   0 C,   0 C,   0 C,   0 C, 
255 C, 128 C, 128 C, 156 C, 156 C, 156 C, 128 C, 128 C, 
255 C,   0 C  , 0 C,  28 C,  28 C,  28 C,   0 C,   0 C, 
128 C, 128 C, 128 C, 156 C, 156 C, 156 C, 128 C, 128 C, 
128 C,   0 C,   0 C,  28 C,  28 C,  28 C,   0 C,   0 C, 
255 C, 128 C, 128 C, 128 C, 136 C, 128 C, 128 C, 128 C, 
255 C,   0 C,   0 C,   0 C,   8 C,   0 C,   0 C,   0 C, 
128 C, 128 C, 128 C, 128 C, 136 C, 128 C, 128 C, 128 C, 
128 C,   0 C,   0 C,   0 C,   8 C,   0 C,   0 C,   0 C, 


( D - ARRAY OF 24 QUADRUPLES OF SEARCH DIRECTIONS FOR MAZE GENERATION )
CREATE D
  3 C,   2 C,   4 C,   1 C, 
  2 C,   3 C,   4 C,   1 C,
  1 C,   4 C,   3 C,   2 C, 
  3 C,   4 C,   2 C,   1 C,
  2 C,   3 C,   1 C,   4 C, 
  3 C,   1 C,   4 C,   2 C,
  4 C,   3 C,   2 C,   1 C, 
  1 C,   2 C,   4 C,   3 C,
  1 C,   3 C,   2 C,   4 C, 
  2 C,   4 C,   1 C,   3 C,
  4 C,   2 C,   1 C,   3 C, 
  4 C,   1 C,   3 C,   2 C,
  1 C,   4 C,   2 C,   3 C, 
  2 C,   1 C,   3 C,   4 C,
  3 C,   1 C,   2 C,   4 C, 
  1 C,   3 C,   4 C,   2 C,
  3 C,   2 C,   1 C,   4 C, 
  3 C,   4 C,   1 C,   2 C,
  4 C,   1 C,   2 C,   3 C, 
  4 C,   3 C,   1 C,   2 C, 
  1 C,   2 C,   3 C,   4 C, 
  4 C,   2 C,   3 C,   1 C,
  2 C,   1 C,   4 C,   3 C, 
  2 C,   4 C,   3 C,   1 C,

( POPULATE GAME GRAPHICS )
: GR ( -- )
    ( ASCII 1 = INTERIOR CELL )
    ( ASCII 2 = BOTTOM WALL )
    ( ASCII 3 = RIGHT-HAND WALL )
    ( ASCII 4 = BOTTOM, RIGHT-HAND CORNER )
    ( ADD 4 TO ASCII VALUE TO INCLUDE MOUSE )
    ( ADD 8 TO ASCII VALUE TO INCLUDE SMALL MOUSE )

    G ( LOCATION OF USER-DEFINED-GRAPHICS DATA )

    96 0 DO 
	DUP @ ( RETRIEVE NEXT TWO BYTES )
	11272 I + ( 11272 IS LOCATION OF ASCII 1 IN MEMORY )
	! ( WRITE TWO BYTES AT A TIME )
	2+ ( ADVANCE TWO BYTES )
	2
    +LOOP

    DROP
;

0 VARIABLE SEED ( SEED FOR RANDOM-NUMBER GENERATOR )

( RANDOM NUMBER GENERATED. SEE STEVEN VICKERS 'FORTH PROGRAMMING' P. 82 )
( FOR DETAILS OF THE IMPLEMENTATION )
: RND ( N -- RND N )
    SEED @
    75 U* 75 0 D+
    OVER OVER U< - -
    1- DUP SEED !
    U* SWAP DROP
;

0 VARIABLE Z ( SIZE OF MAZE IN SECTIONS - 1=SMALL; 2=MEDIUM; 3=LARGE )
0 VARIABLE Y ( TEMPORARY STORE FOR CURRENT OFFSET, WHEN SOLVING MAZE )
0 VARIABLE X ( OFFSET OF CURRENT POSITION IN CURRENT MAZE SECTION )
0 VARIABLE W ( START OF STATUS INFO FOR CURRENT MAZE SECTION )
0 VARIABLE V ( ROW INDEX OF CURRENT MAZE SECTION )
0 VARIABLE U ( COLUMN INDEX OF CURRENT MAZE SECTION )
0 VARIABLE T ( FLAG INDICATING IF ON BOUNDARY OF SECTION )
0 VARIABLE P ( OFFSET OF CURRENT POSITION IN MAZE DISPLAY )
0 VARIABLE P1 ( OFFSET OF START OF MAZE DISPLAY )
0 VARIABLE OX ( WALL CONTAINING EXIT )
0 VARIABLE OV ( ROW COORDINATE OF MAZE SECTION WITH EXIT )
0 VARIABLE OU ( COLUMN COORDINATE OF MAZE SECTION WITH EXIT )
0 VARIABLE IX ( OFFSET OF MAZE ENTRANCE IN INITIAL MAZE SECTION )
0 VARIABLE IV ( ROW COORDINATE OF MAZE SECTION WITH ENTRANCE )
0 VARIABLE IU ( COLUMN COORDINATE OF MAZE SECTION WITH ENTRANCE )


( INITIALISE MAZE GRAPH AND IN-MEMORY COPY OF DISPLAY )
: CLEAR ( SIZE -- )
    ( SIZE = 1, 2, 3 FOR SMALL, MEDIUM, LARGE )
    Z ! ( STORE SIZE IN Z )

    HERE 30 + ( FIND FREE MEMORY IN WHICH TO PUT MAZE )
    DUP W ! ( W HOLDS START OF CURRENT MAZE SECTION )

    Z @ ( RETRIEVE SIZE )
    DUP * 336 * ( 336 = 32*21 / 2 )
    SWAP

    ( FILL MAZE GRAPH WITH ZEROS, TWO BYTES AT A TIME )
    OVER 0 DO
	0 OVER ! 2+ ( 0 = 0000H )
    LOOP
    
    ( AFTER WORKSPACE COMES SCREEN BUFFER )
    DUP P ! ( P HOLDS START OF CURRENT DISPLAY SECTION )
    DUP P1 ! ( P1 HOLDS START OF DISPLAY BUFFER )

    ( FILL SCREEN BUFFER WITH ONES )
    SWAP 0 DO
	257 OVER ! ( 257 = 0101H )
	2+
    LOOP

    DROP ( STACK EMPTY )

    ( FOR EACH BOARD SECTION, SET RIGHT-MOST EDGE TO CONTAIN 03 )
    ( SET BOTTOM EDGE TO BE 02 AND BOTTOM, RIGHT CORNER )
    ( TO BE 04 )
    P @ 1-
    Z @ DUP * 0 DO
	20 0 DO
	    32 + ( MOVE TO END OF CURRENT ROW )
	    3 OVER C!
	LOOP

	1+ ( ADVANCE TO START OF ROW 32 OF SCREEN SECTION )
	16 0 DO
	    514 OVER ! 2+ ( 514 = 0202H )
	LOOP

	1- ( REVERSE ONE CELL, TO GET BOTTOM-RIGHT CORNER )
	4 OVER C!
    LOOP

    DROP ( STACK IS EMPTY )
;

: PRINT ( -- )
    P @ ( RETRIEVE START OF GAME BOARD )

    ( 9216 TO 9983 IS DISPLAY BUFFER )
    9888 9216 DO ( 21*32 CHARS )
	DUP
	@
	I !
	2+
	2
    +LOOP
    
    DROP
    
    ( PRINT GAME SECTION COORDINATES V,U )
    ( AT BOTTOM RIGHT CORNER )
    ( 9916 = 9216 + 21*32 + 28 )

    V @ 48 + ( CONVERT TO ASCII )
    9916 C!
    44 9917 C! ( 44 IS ASCII COMMA )
    U @ 48 + ( CONVERT TO ASCII )
    9918 C!
;

( ADD VALUE TO SCREEN OFFSET )
: SCR ( OFFSET INCREMENT -- OFFSET )
    OVER P @ + ( CALCULATE OFFSET INTO CURRENT SCREEN SECTION )

    DUP C@ ( OFFSET INCREMENT ADDR OLD_VALUE )
    ROT
    + ( OFFSET ADDR NEW_VALUE )

    DUP ROT C! ( SAVE NEW VALUE )
    OVER 9216 + C! ( AND UPDATE ACTUAL DISPLAY )
;

( APPLY OR MASK TO LOCATION IN MAZE GRAPH )
: RAM ( OFFSET MASK -- OFFSET )
    OVER W @ + ( CALCULATE OFFSET INTO GAME BOARD )
    
    DUP C@ ( RETRIEVE VALUE, KEEPING COPY OF ADDRESS )
    ROT ( .S : OFFSET ADDR OLD_VALUE MASK )
    OR ( APPLY MASK )

    SWAP C! ( SAVE NEW VALUE )
;
    ( FIND THE START OF THE ACTIVE BOARD   )
    ( SECTION IN MEMORY.                   )
    ( BOARD CONSISTS OF SIZE*SIZE SECTIONS )
    ( EACH SECTION IS 21*32 SQUARES, OR    )
    ( 672 BYTES, MEANING THE CURRENT       )
    ( SECTION IS SIZE*V + U SECTIONS IN,   )
    ( IN LINEARISED MEMORY                 )

( SET P TO POINT TO START OF CURRENT SCREEN SECTION )
: PSET
    U @ 1- ( RETRIEVE U AND NORMALISE TO ZERO )
    672 * ( WORK OUT ROW OFFSET )
    
    V @ 1- ( RETRIEVE V AND NORMALISE TO ZERO )
    Z @ ( RETRIEVE SIZE )
    * 672 * ( WORK OUT COLUMN OFFSET )

    + ( ADD ROW AND COLUMN OFFSET )
    HERE 30 + ( CALCULATE START OF MAZE GRAPH )
    OVER + W ! ( UPDATE W )

    P1 @ + ( RETRIEVE START OF SCREEN )
    P ! ( STORE START OF CURRENT SCREEN SECTION )
;

( MOVE TO DIFFERENT SECTION )
: PP ( DIRN OFFSET STEPS -- )
    ROT ( BRING DIRECTION TO TOS )
    * ( MULTIPLY BY STEPS )
    672 * ( WORK OUT NUMBER OF CELLS IN MOVE )
    DUP
    W @ + ( UPDATE POINTER TO STATUS INFO )
    W !
    P @ + ( UPDATE POINTER TO DISPLAY INFO )
    P !
    + ( APPLY OFFSET TO CURRENT LOCATION )
    PRINT ( UPDATE DISPLAY )
;

( MOVE UP/ DOWN TO NEW SECTION )
: YP ( DIRN -- )
    DUP
    V @ +
    V ! ( UPDATE ROW INDEX OF CURRENT SECTION )
    DUP
    -608 * ( OFFSET MODIFIER TO USE IN NEW SECTION )
    Z @ ( SET STEPS - NEED TO MOVE Z SECTIONS TO GO DOWN OR UP )
    PP ( MAKE MOVE )
;

( MOVE ACROSS TO NEW SECTION )
: XP ( DIRN -- )
    DUP
    U @ +
    U ! ( UPDATE COLUMN INDEX OF CURRENT SECTION )
    DUP
    -30 * ( OFFSET MODIFIER TO USE IN NEW SECTION ) 
    1 ( .S : DIRN -30*DIR 1 )
    PP ( MAKE MOVE )
;

( MOVE TO NEXT MAZE SECTION ). 
( NOW NOT USED. ASSUME WAS PART OF SCAN ROUTINE )
( USEFUL FOR REVIEWING SOLVED MAZE )
: SP
    U @ Z @
    < IF ( NOT RIGHT-MOST SECTION )
	U @ ( MOVE ONE SECTION RIGHT )
	1+
	U !
    ELSE
	1 U ! ( MOVE TO LEFT-MOST COLUMN )
	V @ Z @
	< IF ( NOT BOTTOM-MOST SECTION )
	    V @ ( MOVE DOWN ONE SECTION )
	    1+
	    V !
	ELSE
	    1 V ! ( MOVE TO TOP-MOST SECTION )
	THEN
    THEN
    PSET ( UPDATE POINTERS INTO MAZE STRUCTURES )
    PRINT
;

( TRY TO GROW MAZE ONE CELL UP )
: Y-
    X @ DUP

    31 > IF ( CHECK NOT TOP ROW OF SECTION )
	32 - ( MOVE UP ONE ROW )
	W @ +
	C@ ( RETRIEVE STATUS )
	128 < IF ( CHECK NOT VISITED )
	    X @
	    4 RAM ( CONFIRM CAN MOVE UP )
	    2 SCR ( REMOVE WALL FROM ABOVE )
	    32 - ( MOVE UP )
	    8 RAM ( CONFIRM CAN MOVE DOWN )
	    X ! ( STORE NEW POSITION )
	    1 ( CONFIRM SUCCESS )
	ELSE
	    0 ( CONFIRM FAILED, AS CELL ABOVE ALREADY VISITED )
	THEN
    ELSE
	V @ 1 > ( CHECK NOT TOP SECTION )
	OVER 608 + ( ASSUME IS AND EXTRACT STATUS INFO FOR CELL ABOVE )
	W @ +
	672 Z @ * ( 672 = 32 * 21 IS SIZE OF A MAZE SECTION )
	-
	C@
	128 < ( CHECK NOT VISITED )
	AND IF ( IF SECTION ABOVE AND CELL NOT VISITED )
	    132 RAM ( CONFIRM CELL IS VISITED AND CAN MOVE UP - 132 = %10000100 )
	    2 SCR ( REMOVE WALL AVOVE )
	    -1 YP ( MOVE UP ONE SECTION )
	    DUP 32 + ( MOVE DOWN A ROW )
	    2 SCR ( REMOVE WALL ABOVE )
	    DROP ( CANCEL MOVE DOWN )
	    8 RAM ( CONFIRM CAN MOVE DOWN )
	    X ! ( STORE NEW LOCATION )
	    1 ( CONFIRM SUCCESS )
	ELSE
	    DROP ( BALANCE STACK )
	    0  ( CONFIRM FAILED, AS NO SECTION ABOVE )
	THEN
    THEN
;

( TRY TO GROW THE MAZE ONE CELL DOWN ) 
: Y+ ( -- FLAG )
    X @ DUP

    608 < IF ( CHECK NOT BOTTOM ROW OF SECTION )
	32 + W @ + C@ ( EXTRACT STATUS INFO FROM CELL BELOW )

	128 < IF ( IF NOT VISITED )
	    X @
	    8 RAM ( CONFIRM CAN MOVE DOWN )
	    32 + ( MOVE DOWN )
	    2 SCR ( REMOVE WALL FROM ABOVE )
	    4 RAM ( CONFIRM CAN MOVE UP )
	    32 RAM ( SET BREADCRUMB TRAIL )
	    X ! ( STORE NEW LOCATION )
	    1 ( CONFIRM SUCCESS )
	ELSE
	    0 ( CONFIRM FAILED, AS CELL BELOW ALREADY VISITED )
	THEN
    ELSE
	V @ Z @ < ( CHECK IF SECTION BELOW CURRENT SECTION )
	OVER 608 - ( ASSUME IS AND EXTRACT STATUS INFO FROM CELL BELOW )
	W @ + 
	672 Z @ * ( 672 = 32 * 21 IS SIZE OF A MAZE SECTION )
	+
	C@
	128 < ( CHECK NOT VISITED )
	AND IF ( IF SECTION BELOW AND CELL NOT VISITED )
	    136 RAM ( CONFIRM IS VISITED AND CAN MOVE DOWN - 136 = %10001000 )
	    DUP
	    32 + ( ADVANCE TO NEXT ROW, OF CURRENT SECTION )
	    2 SCR ( REMOVE WALL FROM ABOVE )
	    DROP ( .S : OFFSET )
	    1 YP ( MOVE DOWN ONE SECTION )
	    2 SCR ( REMOVE WALL ABOVE )
	    4 RAM ( CONFIRM CAN MOVE UP )
	    32 RAM ( UPDATE BREADCRUMB TRAIL )
	    X ! ( STORE NEW LOCATION )
	    1 ( CONFIRM SUCCESS )
	ELSE
	    DROP
	    0 ( CONFIRM FAILED, AS NO SECTION BELOW CURRENT )
	THEN
    THEN
;

( TRY TO GROW MAZE ONE CELL TO THE LEFT )
: X- ( -- FLAG )
    X @ DUP 31 AND ( EXTRACT COLUMN INDEX OF CURRENT LOCATION )

    ( .S : OFFSET COL )
    
    0 >  IF ( CHECK NOT LEFT-MOST COLUMN )
	( EXTRACT STATUS INFO FROM CELL TO LEFT )
	1- W @ + C@

	128 < IF ( CHECK NOT VISITED ALREADY )
	    X @
	    2 RAM ( CONFIRM CAN MOVE LEFT FROM CURRENT LOCATION - 2 = %00000010 )
	    1 SCR ( REMOVE WALL TO RIGHT )
	    1- ( MOVE LEFT )
	    1 RAM ( CONFIRM CAN MOVE LEFT - 1 = %00000001 )
	    16  RAM ( SET BREADCRUMB TRAIL - 16 = %00010000 )
	    X ! ( STORE NEW LOCATION )
	    1 ( CONFIRM SUCCESS )
	ELSE
	    0 ( CONFIRM FAILED, AS ALREADY VISITED )
	THEN
    ELSE
	( .S : OFFSET )
	U @ 1 > ( CHECK IF SCREEN SECTION TO LEFT )
	OVER 642 - ( ASSUME SO, AND EXTRACT STATUS INFO FROM CELL TO LEFT IN NEXT SECTION - 642 = 32*21 - 30 )
	W @ + C@ ( RETRIEVE STATUS )
	128 < ( CHECK NOT VISITED )
	AND IF ( SECTION TO LEFT AND NOT VISITED )
	    130 RAM ( MARK AS VISITED AND CONFIRM CAN MOVE LEFT - 130 = %10000010 )
	    1 SCR ( REMOVE WALL TO LEFT )
	    -1 XP 1+ ( MOVE LEFT )
	    1 SCR ( REMOVE WALL TO LEFT, AGAIN )
	    1- ( MOVE LEFT )
	    1 RAM ( CONFIRM CAN MOVE RIGHT - 1 = %00000001 )
	    16 RAM ( UPDATE BREADDCRUMB TRAIL  - 16 = %00010000 )
	    X ! ( STORE NEW LOCATION )
	    1 ( CONFIRM SUCCESS )
	ELSE
	    DROP 0 i ( FAILED, AS LEFT BOUNDARY OF MAZE )
	THEN
    THEN
;

( TRY TO GROW MAZE ONE CELL TO THE RIGHT )
: X+ ( -- FLAG )
    X @ DUP 31 AND ( EXTRACT COLUMN INDEX OF CURRENT LOCATION )

    ( .S : OFFSET COL )
    
    30 < IF ( CHECK NOT RIGHT-MOST COLUMN )
	( EXTRACT STATUS INFO FOR CELL TO RIGHT )
	1+ W @ + C@

	128 < IF ( CHECK NOT VISITED ALREADY )
	    X @
	    1 RAM ( CONFIRM CAN MOVE RIGHT FROM CURRENT LOCATION - 1 = %00000001 )
	    1+ ( MOVE RIGHT )
	    1 SCR ( REMOVE WALL TO LEFT )
	    2 RAM ( CONFIRM CAN MOVE LEFT - 2 = %00000010 )
	    48 RAM ( SET BREADCRUMB TRAIL  - 48 = %00110000 )
	    X ! ( STORE NEW LOCATION )
	    1 ( CONFIRM SUCCESS )
	ELSE
	    0 ( CONFIRM FAILED, AS ALREADY VISITED )
	THEN
    ELSE
	( .S : OFFSET )
	U @ Z @ < ( CHECK IF SCREEN SECTION TO RIGHT )
	OVER 642 + ( ASSUME SO, AND EXTRACT STATUS INFO FROM CELL TO RIGHT IN NEXT SECTION - 642 = 32*21 - 30 )
	W @ + C@ ( RETRIEVE STATUS )
	128 < ( CHECK NOT VISITED )
	AND IF ( IF SECTION TO RIGHT AND NOT VISITED )
	    129 RAM ( MARK AS VISITED AND CONFIRM CAN MOVE RIGHT - 129 = %10000001 )
	    1+ ( MOVE RIGHT, INTO BOUNDARY COLUMN )
	    1 SCR ( REMOVE WALL BETWEEN CURRENT LOCATION AND BOUNDARY OF SECTION )
	    1- ( MOVE BACK TO CURRENT CELL )
	    1 XP ( MOVE ONE SECTION RIGHT )
	    1 SCR ( REMOVE BOUNDARY BETWEEN NEW LOCATION AND BOUNDARY OF SECTION )
	    2 RAM ( CONFIRM CAN MOVE LEFT FROM NEW LOCATION  - 2 = %00000010 )
	    48 RAM ( SET BREADCRUMB TRAIL  - 48 = %00110000 )
	    X ! ( STORE NEW LOCATION )
	    1 ( CONFIRM SUCCESS )
	ELSE
	    DROP ( BALANCE STACK )
	    0 ( CONFIRM FAILURE )
	THEN
    THEN
;

( BACKTRACK FROM A DEAD-END DURING MAZE GENERATION )
: SCAN ( -- )
    X @ W @ + ( RETRIEVE STATUS INFORMATION FOR CURRENT LOCATION )
    C@
    48 AND 16 / ( EXTRACT BITS 4 AND 5 AND RESCALE ONTO 0..3 )

    DUP 0 = IF ( CAME FROM BELOW )
	X @ DUP

	608 < IF ( IF NOT BOTTOM ROW, MOVE DOWN ONE ROW )
	    32 +
	    X !
	ELSE ( OTHERWISE MOVE TO NEXT SECTION DOWN )
	    1 YP
	    X !
	THEN
    ELSE
	DUP 1 = IF ( CAME FROM RIGHT )
	    X @ DUP

	    31 AND 30 < IF 9 ( IF NOT RIGHT-MOST COLUMN, MOVE RIGHT )
		1+
		X !
	    ELSE ( OTHERWISE MOVE TO NEXT SECTION RIGHT )
		1 XP
		X !
	    THEN
	ELSE
	    DUP 2 = IF ( CAME FROM ABOVE )
		X @
		DUP 31 > IF ( IF NOT FIRST ROW, MOVE UP )
		    32 -
		    X !
		ELSE ( OTHERWISE MOVE UP A MAZE SECTION )
		    -1 YP
		    X !
		THEN
	    ELSE ( MUST HAVE COME FROM LEFT )
		X @
		DUP 31 AND 0 > IF ( IF NOT LEFT-MOST COLUMN, MOVE LEFT )
		    1-
		    X !
		ELSE ( OTHERWISE ONE SECTION TO LEFT )
		    -1 XP
		    X !
		THEN
	    THEN
	THEN
    THEN
    
    DROP ( BALANCE STACK )
;

( USED WHEN CREATING MAZE TO ADVANCE TO NEXT AVAILABLE SQUARE )
: MOVE ( OFFSET -- NEW_OFFSET )
    ( CHECK IF OFFSET < 150*SIZE^2 AND SET T ACCORDINGLY )
    ( THIS INFORMATION IS NEVER USED, MAKING ME THINK THERE IS SOME )
    ( CORRUPTION HERE. IN OTHER PARTS OF THE PROGRAM, T INDICATES IF )
    ( THE MOUSE WILL MOVE INTO A NEW MAZE SECTION, SO PERHAPS THAT )
    ( WAS INTENDED HERE TOO )
    DUP
    150 Z @ DUP
    * *

    < IF
	1 T !
    ELSE
	0 T !
    THEN

    ( .S : OFFSET )
    BEGIN
	24 RND ( PICK RANDOM NUMBER BETWEEN 0 AND 23 )
	DUP + DUP + ( THEM MULTIPLY BY 4 )
	1- D + 4 ( INDEX INTO D, WHICH STORES SEQUENCES OF SEARCH DIRECTIONS )

	( .S : OFFSET DIRN COUNT )
	BEGIN
	    OVER OVER + C@ ( RETRIEVE NEXT DIRECTION FROM D ARRAY )

	    DUP 1 = IF ( TRY TO MOVE RIGHT )
		X+
	    ELSE
		DUP 2 =	IF ( TRY TO MOVE LEFT )
		    X-
		ELSE
		    DUP 3 = IF ( TRY TO MOVE DOWN )
			Y+
		    ELSE ( TRY TO MOVE UP )
			Y- 
		    THEN
		THEN
	    THEN

	    IF ( MOVED, THEN CLEAR STACK AND EXIT )
		DROP DROP DROP ( .S : OFFSET )
		EXIT
	    THEN

	    DROP ( .S : OFFSET DIR COUNT )

	    1- ?DUP ( CHECK IF FURTHER DIRECTIONS TO TRY ... )
	WHILE
	REPEAT ( ... REPEAT, IF SO )

	( IF GET THIS FAR, THEN AT A DEAD END )
	DROP ( .S : OFFSET )
	
	SCAN ( BACKTRACK ONE STEP )

	0 ( AND TRY AGAIN )
    UNTIL
;


( CREATE DOOR -- THAT IS, ENTRY OR EXIT -- ON BORDER OF MAZE )
: DOOR ( N -- OFFSET CHAR )
    ( N  -- SIDE ON WHICH TO LOCATE DOOR 0=RIGHT; 1=TOP; 2=BOTTOM; 3=LEFT )
    ( OFFSET HOLDS OFFSET TO LOCATION OF DOOR IN CURRENT SECTION )
    ( CHAR INDICATES MODIFICATION TO BE APPLIED TO SCREEN FILE TO SHOW DOOR )

    3 OVER -
    OX ! ( STORE OPPOSITE WALL, WHICH WILL BE FOR EXIT, IF COMPUTING ENTRY )

    ( THIS IS EFFECTIVELY A BIG CASE STATEMENT )
    ?DUP IF ( IF N > 0 )
	1-
	?DUP IF ( IF N > 1 )
	    1-
	    ?DUP IF ( IF N = 3, LEFT-HAND WALL )
		20 RND 32 * ( RANDOMLY SELECT LOCATION ON LEFT-HAND WALL OF MAZE SECTION )
		DUP 
		X ! ( STORE IN X )

		( WORK OUT WHICH SECTION )
		1 U ! ( AS LEFT-HAND WALL, U MUST BE 1 )
		Z @ RND 1+ 
		V ! ( V RANDOMLY CHOSEN FROM 1, ..., Z+1 )
		SWAP ( .S : OFFSET 3 )
		
	    ELSE ( N = 2, BOTTOM WALL )
		31 RND 608 + ( RANDOMLY SELECT LOCATION ON BOTTOM WALL OF MAZE SECTION -- NOTE 608 = 19*32 )
		DUP X ! ( STORE IN X )

		( WORK OUT WHICH SECTION )
		Z @ DUP V ! ( AS RIGHTHAND SIDE, V MUST BE Z )
		RND 1+ U ! ( U RANDOMLY CHOSEN FROM 1, ..., Z+1 )
		32 + ( ADVANCE ONE ROW, AS IMAGE CORRECTION IS APPLIED ON ROW BELOW )
		2 ( .S : OFFSET 2 )
	    THEN
	ELSE ( N = 1, TOP WALL )
	    31 RND ( RANDOMLY SELECT LOCATION ON TOP WALL OF MAZE SECTION )
	    DUP X ! ( STORE IN X )

	    ( WORK OUT WHICH SECTION )
	    1 V ! ( AS TOP, V MUST BE 1 )
	    Z @ RND 1+ U ! ( U RANDOMLY CHOSEN FROM 1, ..., Z+1 )
	    2 ( .S : OFFSET 2 )
	THEN
    ELSE ( N = 0, RIGHT-HAND WALL )
	20 RND ( RANDOMLY CHOOSE ROW FOR ENTRY )
	32 * 30	+ ( WORK OUT OFFSET TO RIGHT-HAND WALL )
	DUP X ! ( STORE ENTRY LOCATION )
	Z @ DUP U ! ( U MUST BE RIGHT-MOST SECTION )
	RND ( WORK OUT VERTICAL SECTION, RANDOMLY )
	1+ V ! ( NORMALISE TO 1 AND STORE )
	1+ ( ADVANCE OFFSET TO NEXT CELL, AS RIGHTHAND WALL IS IN NEIGHBOUR )
	1 ( .S : OFFSET 1 )
    THEN
    
    PSET ( UPDATE MAZE-GRAPH AND SCREEN SECTION ADDR )
;

: PATH
    Z @ DUP * 620 * 1-
    BEGIN
	X @ ( RETRIEVE CURRENT LOCATION )
	128 RAM	DROP ( MARK AS VISITED )

	MOVE
	
	1- ?DUP ( CHECK IF NOT FINISHED )
    WHILE ( REPEAT, IF SO )
    REPEAT
;

: DRAW ( -- )
    4 RND ( CHOOSE ON WHICH SIDE TO LOCATE THE DOOR )
    DOOR ( RANDOMLY POSITION THE DOOR )
    ( .S : DOOR_OFFSET MODIFIER )

    X @ IX ! ( STORE CURRENT LOCATION AS INITIAL POSITION )
    U @ IU ! ( STORE CURRENT U AND V VALUES AS INITIAL MAZE SECTION )
    V @ IV !
    
    PRINT

    ( .S : DOOR_OFFSET MODIFIER )
    SCR DROP ( UPDATE SCREEN-DISPLAY TO MAKE ENTRANCE )

    PATH ( GENERATE THE MAZE )

    OX @ DOOR ( POSITION THE MAZE EXIT )
    ( .S : DOOR_OFFSET MODIFIER)
    
    X @ 64 RAM ( RECORD IN MAZE STRUCTURE )
    OX ! ( UPDATE OX, OU AND OV TO HOLD LOCATION OF EXIT )
    U @ OU !
    V @ OV !
    
    ( .S : DOOR_OFFSET X MODIFIER)
    SCR DROP ( UPDATE SCREEN-DISPLAY TO MAKE EXIT )
;

: SRAM ( X N -- X )
    OVER 
    W @ + 
    DUP C@ ( .S : X N LOC VAL )
    ROT AND ( .S : X LOC NEW_VAL )
    SWAP
    C! ( STORE UPDATED VALUE )
;

: MOUSE ( X FLAG -- X )
    IF
	( LOOP FOR 300*[4-Z] )
	4
	Z @ - 300
	* 0
	DO
	LOOP
    THEN
    
    4 SCR
;

( TRY TO MOVE MOUSE UP.                                         )
( FIRST, CHECK IF SQUARE ABOVE HAS BEEN VISITED.                )
(    IF SO, THEN CHECK IF THERE ARE OTHER OPTIONS TO LEAVE CELL )
(       IF THERE ARE, THEN EXIT, SO CAN TRY THOSE OPTIONS       )
(    OTHERWISE, KNOW AT DEAD END, SO                            )
(       BACKTRACK UP BUT BLOCK OFF CELL BELOW                   )
( OTHERWISE, NOT VISITED SO                                     ) 
(    MOVE UP NORMALLY                                          )
: UP ( OFFSET -- NEW_OFFSET FLAG )
    DUP
    DUP 32 < ( CHECK IF FIRST ROW )
    DUP T ! ( STORE ANSWER IN T )

    ( .S : OFFSET OFFSET FLAG )
    IF ( FIRST ROW OF SECTION )
	640 + Z @ 672 * - ( CALCULATE CORRESPONDING LOCATION IN ABOVE SECTION )
    THEN
    
    32 - W @ + C@ ( MOVE UP AND RETRIEVE STATUS OF CELL )

    16 AND ( CHECK IF VISITED )
    IF
	DUP W @ + C@ ( RETRIEVE STATUS AT CURRENT LOCATION )
	11 AND ?DUP ( CHECK IF OTHER DIRECTIONS TO TRY, 11 = %00001011 )
	IF
	    EXIT ( .S : OFFSET FLAG ) ( FLAG IS NON-ZERO )
	ELSE
	    0 MOUSE ( PRINT SMALL MOUSE POINTER )
	    139 SRAM ( UPDATE STATUS TO PREVENT MOVING DOWN; 139 = %10001011 )

	    ( MOVE UP )
	    T @ IF ( NEED TO CHANGE SCREEN SECTION )
		-1 YP
	    ELSE ( NORMAL MOVE )
		32 -
	    THEN
	    
	    151 SRAM ( PREVENT MOVE DOWN - 151 = 10010111 )
	THEN
    ELSE ( MOVE UP )
	T @ IF ( NEED TO CHANGE SCREEN SECTION )
	    -1 YP
	ELSE ( NORMAL MOVE )
	    32 -
	THEN
	1 MOUSE ( PRINT MOUSE )

	16 RAM ( SET CELL TO BE VISITED )
    THEN
    
    0 ( INDICATING HAS MOVED )
;

( TRY TO MOVE DOWN.                                             )
( FIRST, CHECK IF SQUARE BELOW HAS BEEN VISITED.                )
(    IF SO, THEN CHECK IF THERE ARE OTHER OPTIONS TO LEAVE CELL )
(       IF THERE ARE, THEN EXIT, SO CAN TRY THOSE OPTIONS       )
(    OTHERWISE, KNOW AT DEAD END, SO                            )
(       BACKTRACK DOWN BUT BLOCK OFF CELL ABOVE                 )
( OTHERWISE, NOT VISITED SO                                     ) 
(    MOVE DOWN NORMALLY                                         )
: DN ( OFFSET -- NEW_OFFSET FLAG )
    DUP
    DUP 607 > ( CHECK IF FINAL ROW OF CURRENT SECTION )
    DUP T ! ( STORE ANSWER IN T )

    IF ( FINAL ROW )
	640 - Z @ 672 * + ( WORK OUT OFFSET TO CORRESPONDING POSN IN SECTION BELOW )
    THEN
    
    32 + W @ + ( MOVE DOWN ONE ROW )
    C@ ( AND RETRIEVE STATUS FOR THAT CELL )

    16 AND IF ( HAS BEEN VISITED )
	DUP W @ + C@ ( RETRIEVE STATUS OF CURRENT LOCATION )
	7 AND ?DUP ( CHECK IF ANY OTHER DIRECTIONS TO TRY )
	IF ( OTHER DIRECTION TO TRY, THEN EXIT )
	    EXIT  ( WITH TOS NON-ZERO )
	ELSE
	    0 MOUSE ( REPRINT SMALL MOUSE, TO INDICATE BACKTRACK )
	    135 SRAM ( PREVENT MOVE UP , 135 = %10000111 )

	    T @ ( MOVE DOWN )
	    IF ( NEED TO CHANGE SCREEN SECTION )
		1 YP
	    ELSE ( NORMAL MOVE )
		32 +
	    THEN
	    
	    155 SRAM ( PREVENT MOVE UP , 155 = %10011011 )
	THEN
    ELSE ( MOVE DOWN )
	T @ IF ( NEED TO CHANGE SCREEN SECTION )
	    1 YP
	ELSE ( NORMAL MOVE )
	    32 +
	THEN
	
	1 MOUSE ( PRINT MOUSE )

	16 RAM ( SET CELL TO BE VISITED )
    THEN

    0 ( INDICATING HAS MOVED )
;

( TRY TO MOVE LEFT                                              )
( FIRST, CHECK IF SQUARE TO LEFT HAS BEEN VISITED.              )
(    IF SO, THEN CHECK IF THERE ARE OTHER OPTIONS TO LEAVE CELL )
(       IF THERE ARE, THEN EXIT, SO CAN TRY THOSE OPTIONS       )
(    OTHERWISE, KNOW AT DEAD END, SO                            )
(       BACKTRACK LEFT BUT BLOCK OFF RIGHT CELL                 )
( OTHERWISE, NOT VISITED SO                                     ) 
(    MOVE RIGHT NORMALLY                                        )
: LT ( OFFSET -- NEW_OFFSET FLAG )
    DUP
    DUP 31 AND ( ISOLATE COLUMN VALUE OF CURRENT LOCATION )
    0= ( CHECK IF COLUMN ZERO )
    DUP T ! ( STORE OUTCOME OF TEST )

    IF ( COLUMN ZERO )
	641 - ( SUBTRACT 20 ROWS PLUS ONE )
    THEN
    
    1- W @ + C@ ( MOVE LEFT AND RETRIEVE VALUE )
    
    16 AND IF ( CHECK IF VISITED )
	DUP
	W @ + C@
	13 AND ( CHECK IF OTHER DIRECTIONS TO TRY )

	?DUP IF ( OTHER DIRECTIONS TO TRY, THEN TRY THEM )
	    EXIT ( WITH TOS NON-ZERO )
	ELSE 
	    0 MOUSE ( REPRINT SMALL MOUSE, TO INDICATE BACKTRACK )
	    141 SRAM ( PREVENT MOVE RIGHT : 141 = %10001101 )
	    
	    ( MOVE LEFT )
	    T @ 
	    IF
		-1 XP
	    ELSE
		1-
	    THEN
	    
	    158 SRAM ( PREVENT MOVE LEFT : 158 = %10011110 )
	THEN
    ELSE ( MOVE DOWN NORMALLY )
	T @
	IF
	    -1 XP
	ELSE
	    1-
	THEN
	1 MOUSE 16 RAM
    THEN
    
    0 ( INDICATES MOVED )
;

( TRY TO MOVE RIGHT.                                            )
( FIRST, CHECK IF SQUARE TO RIGHT HAS BEEN VISITED.             )
(    IF SO, THEN CHECK IF THERE ARE OTHER OPTIONS TO LEAVE CELL )
(       IF THERE ARE, THEN EXIT, SO CAN TRY THOSE OPTIONS       )
(    OTHERWISE, KNOW AT DEAD END, SO                            )
(       BACKTRACK RIGHT BUT BLOCK OFF LEFT CELL                 )
( OTHERWISE, NOT VISITED SO                                     ) 
(    MOVE RIGHT NORMALLY                                        )
: RT ( OFFSET -- NEW_OFFSET FLAG )
    DUP DUP
    31 AND ( EXTRACT COLUMN INDEX )

    30 = ( CHECK IF COLUMN 30 )
    DUP T ! ( STORE ANSWER )

    ( .S : X X FLAG )
    IF ( IF COLUMN 30 ADD 
	641 + ( ADD 20 ROWS AND ONE EXTRA )
    THEN
    
    1+ ( MOVE RIGHT )

    ( .S : X NX )
    W @ + C@ ( RETRIEVE VALUE )

    16 AND ( CHECK IF VISITED ALREADY )

    IF ( VISITED )
	( .S : X )
	DUP
	W @ + C@ ( RETRIEVE STATUS FOR CURRENT LOCATION )
	14 AND ( CHECK IF CAN MOVE IN ANOTHER DIRECTION : 14 = 00001110 )

	?DUP ( IF SO, DUPLICATE )
	
	IF 
	    EXIT ( .S : X FLAG ) ( FLAG IS NON-ZERO )
	ELSE ( NO WHERE ELSE TO MOVE )
	    ( .S : X )
	    0 MOUSE ( UPDATE TO SMALL MOUSE POINTER )
	    
	    142 SRAM ( PREVENT MOVE LEFT ; 142 = % 10001110 )

	    ( MOVE RIGHT, CHECKING IF NEED TO MOVE SECTION )
	    T @ IF
		1 XP
	    ELSE
		1+
	    THEN
	    
	    157 SRAM ( PREVENT MOVE RIGHT : 157 = %10011101 )
	THEN
    ELSE ( IF NOT VISITED )
	T @ ( CHECK IF SCREEN SWAP )
	IF 
	    1 XP ( MOVE RIGHT TO NEXT SCREEN SECTION )
	ELSE
	    1+ ( MOVE RIGHT )
	THEN

	1 MOUSE ( PRINT MOUSE AT NEW LOCATION, PAUSING FIRST )
	16 RAM ( MARK LOCATION AS VISITED )
    THEN
    
    0 ( INDICATES MOVED )
;

( MAKE A MOVE IN AUTO MODE )
: CHOICE ( X -- X FLAG )
    DUP W @ + C@ ( RETRIEVE INFO ABOUT CURRENT LOCATION )
    Y ! ( SAVE TO Y )
    Y @

    1 AND IF ( CHECK IF CAN MOVE RIGHT )
	RT ( IF SO, TRY )

	0= IF ( IF SUCCESSFUL, DONE )
	    EXIT
	THEN
    THEN

    Y @
    2 AND IF ( CHECK IF CAN MOVE LEFT )
	LT

	0= IF ( IF SUCCESSFUL, DONE )
	    EXIT 
	THEN
    THEN

    Y @

    4 AND IF ( CHECK IF CAN MOVE UP )
	UP

	0= IF ( IF SUCCESSFUL, DONE )
	    EXIT
	THEN
    THEN

    Y @
    
    8 AND IF ( CHECK IF CAN MOVE DOWN )
	DN

	0= IF ( IF SUCCESSFUL, DONE )
	    EXIT
	THEN
    THEN

;

( AUTOMATICALLY SOLVE MAZE )
: AUTO ( -- )
    IX @ ( RETRIEVE STARTING POSITION )
    16 RAM ( MARK AS VISITED )

    ( .S : X )
    BEGIN
	W @ OVER + ( RETRIEVE PROPERTIES FOR CURRENT LOCATION )
	C@
	64 AND 0= ( CHECK IF BIT 6 IS SET, INDICATING EXIT ) 
    WHILE
	    ( IF NOT, MAKE NEXT MOVE )
	    CHOICE
    REPEAT
    
    DROP ( EMPTY STACK BEFORE RETURNING )
;

( WAIT FOR KEYPRES )
: WAIT ( --- KEY )
    1000 0 ( WAIT BRIEFLY, IN CASE OF PREVIOUS KEY PRESS? )
    DO
    LOOP
    
    BEGIN
	INKEY
	?DUP 
    UNTIL ( REPEAT UNLESS KEY IS PRESSED )
;

( MOVE UP OR DOWN )
: UD ( SIGN DIRN -- )
    X @ W @ +
    C@ ( RETRIEVE STATUS FOR CURRENT POSITION )
    AND IF ( CHECK MOVE IS VALID )
	X @
	-4 SCR ( DELETE MOUSE )
	OVER 1 = ( RETRIEVE SIGN AND CHECK IF DOWN )
	OVER 607 > ( CHECK IF BOTTOM ROW OF SECTION )
	AND
	3 PICK -1 = ( RETRIEVE SIGN AND CHECK IF DOWN )
	3 PICK 32 < ( CHECK IF TOP ROW OF SECTION )
	AND
	OR ( IF EITHER UP AND TOP ROW OR DOWN AND BOTTOM ROW )
	( .S SIGN OFFSET )
	IF
	    SWAP YP ( CHANGE SECTION )
	ELSE
	    SWAP 32 * + ( MOVE NORMALLY )
	THEN
	4 SCR ( PRINT MOUSE )
	X ! ( UPDATE LOCATION )
	1 ( CONFIRM SUCCESS )
    ELSE
	DROP ( BALANCE STACK )
	0 ( CONFIRM FAILURE )
    THEN
;

( MOVE LEFT OF RIGHT )
: LR ( SIGN DIRN -- )
    X @ W @ +
    C@ ( RETRIEVE STATUS FOR CURRENT POSITION )
    AND IF ( CHECK MOVE IS VALID )
	X @
	-4 SCR ( DELETE MOUSE )
	OVER 1 = ( CHECK IF MOVING RIGHT )
	OVER 31 AND ( RETRIEVE COLUMN INDEX )
	30 = ( CHECK IF RIGHT-MOST COLUMN )
	AND
	3 PICK 	-1 = ( CHECK IF MOVING LEFT )
	3 PICK 31 AND  ( RETRIEVE COLUMN INDEX )
	0= ( CHECK IF LEFT-MOST COLUMN )
	AND
	OR

	( .S SIGN OFFSET )
	IF ( EITHER RIGHT AND RIGHT-MOST COLUMN OR  LEFT AND LEFT-MOST COLUMN )
	    SWAP XP ( MOVE SECTION )
	ELSE
	    + ( MOVE NORMALLY )
	THEN
	4 SCR ( PRINT MOUSE )
	X ! ( UPDATE LOCATION )
	1 ( CONFIRM SUCCESS )
    ELSE
	DROP ( BALANCE STACK )
	0 ( CONFIRM FAILURE )
    THEN
;

( MANUALLY TRY TO MOVE MOUSE BY ONE CELL )
: STEP ( -- )
    BEGIN
	WAIT ( RETRIEVE KEYPRESS )
	95 AND ( CAPITALISE )
	DUP 65 = IF ( 'A' = UP )
	    DROP
	    -1 4 UD
	ELSE
	    DUP 90 = IF ( 'Z' = DOWN )
		DROP
		1 8 UD
	    ELSE
		DUP 75 = IF ( 'K' = RIGHT )
		    DROP
		    1 1 LR
		ELSE
		    DUP 77 = IF ( 'M' = LEFT )
			DROP
			-1 2 LR
		    ELSE ( INVALID KEYPRESS )
			DROP 0
		    THEN
		THEN
	    THEN
	THEN
    UNTIL ( REPEAT, IF NO VALID KEYPRESS )
;

: MAN ( -- )
    BEGIN
	STEP

	( RETRIEVE CURRENT LOCATION AND CHECK IF EXIT )
	X @
	W @
	+
	C@
	64 AND ( EXIT INDICATED BY BIT 6 BEING SET )
    UNTIL
;

( REMOVE BREADCRUMB TRAIL FROM MAZE GRAPH )
( *** NEW WORD, NOT PART OF ORIGINAL PROGRAM *** )
: CLEARTRAIL ( --- )
    HERE 30 + ( FIND START OF MAZE STRUCTURE )
    Z @ DUP * 672 * ( WORK OUT SIZE OF STRUCTURE )
    0 DO
	DUP
	C@ ( RETRIEVE CURRENT VALUE )
	207 AND ( ZERO BITS 4 AND 5 : 207 = %11001111)

	OVER C! ( STORE UPDATED VALUE )

	1+ ( MOVE TO NEXT ADDRESS )
    LOOP
    
    DROP ( CLEAR STACK )
;

: INSTRS ( --- )
    INVIS ( HIDE FORTH MONITOR CONFIRMATIONS )
    CLS

    3 8 AT ." A-MOUZ-IN-MASE " ( USE INVERSE VIDEO AND PAD WITH ONE SPACE )
    5 8 AT ." An experience in"
    7 9 AT ." MAZE-O-CHISM" ( USE INVERSE VIDEO AND PAD WITH ONE SPACE )
    10 0 AT ."  This program constructs a maze before your very eyes, no less. "
    CR
    ." You ca. solve it yourself, usingthe A, Z, K and M keys; or watcha very short-sighted, timorous, and elasticated mouse, riccochetfrom start to finish."
    ( KEYS ARE PRINTED INVERSE VIDEO, TYPOS ARE PRESERVED FROM ORIGINAL )

    22 23 AT ." <ANYKEY>"

    GR ( INITIALISE GRAPHICS )

    WAIT ( WAIT FOR KEY PRESS )
    DROP
;

( CALL TO RUN PROGRAM )
: RUN ( --- )
    INSTRS ( DISPLAY INSTRUCTIONS )
    CLS
    
    BEGIN
	16 0 AT ." ? Maze size"
	16 16 AT ." 1 Small" ( OPTION NUMBERS ARE PRINTED IN INVERSE VIDEO )
	17 16 AT ." 2 Medium"
	18 16 AT ." 3 Large"

	BEGIN
	    WAIT ( WAIT FOR KEY PRESS )
	    48 - ( SUBTRACT ASCII "1" )
	    DUP ( CHECK IS VALID SELECTION )
	    1 < OVER 3 > OR
	WHILE
		DROP ( TRY AGAIN IF NOT VALID SELECTION )
	REPEAT
	
	CLS 
	CLEAR ( SET UP SPACE FOR MAZE IN MEMORY )

	FAST ( SWITCH TO FAST MODE )
	DRAW ( CREATE MAZE )

	IU @ U ! ( SET CURRENT MAZE SECTION TO INITIAL SECTION )
	IV @ V !
	PSET ( UPDATE P AND W POINTERS FOR RIGHT SECTIN )

	PRINT ( PRINT CURRENT MAZE SECTION )

	IX @ ( RETRIEVE STARTING POSITION -- THAT IS, OFFSET )
	4 SCR ( PRINT MOUSE )
	X ! ( SAVE CURRENT OFFSET )
	
	CLEARTRAIL ( REMOVE BREADCRUMB TRAIL FROM MAZE GRAPH )

	SLOW ( RE-ENABLE KEYBOARD INTERACTIONS )

	22 10 AT ." Play or Watch?" ( *** WAS CORRUPTED *** )

	BEGIN
	    WAIT ( WAIT FOR KEYPRESS )
	    95 AND ( CAPITALISE )
	    DUP
	    80 = IF ( PLAY? )
		DROP
		22 10 AT 15 SPACES ( CLEAR MESSAGE )
		MAN ( PLAY GAME )
		1 ( INDICATES SUCCESS )
	    ELSE 
		DUP
		87 = IF ( WATCH? )
		    DROP
		    22 10 AT 15 SPACES

		    FAST
		    AUTO ( SOLVE MAZE AUTOMATICALLY )
		    SLOW
		    
		    1 ( SUCCESS )
		ELSE
		    DROP
		    0
		THEN
	    THEN
	UNTIL

	( WAIT FOR ~ 1 SECOND ??? SHOULD BE LONGER ??? )
	5000 0 DO
	LOOP

	CLS

	0 ( INFINITE LOOP, SO GO BACK FOR ANOTHER GO )
    UNTIL
;

( PRINT CONTENTS OF ARRAY FOR INSPECTION )
: DISPG ( -- )
    CR
    12 0 DO
	8 0 DO
	    G @
	    J 8 * +
	    I +
	    C@ .
	LOOP

	CR
    LOOP
;

( EXTRA WORD - REVIEW MAZE SECTIONS IN TURN )
: VIEWMAZE ( -- )
    BEGIN
	BEGIN
	    INKEY
	    ?DUP
	UNTIL

	81 = IF
	    EXIT
	THEN
	
	SP

	
	0
    UNTIL
;
